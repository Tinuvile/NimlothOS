//! # 任务上下文模块
//!
//! 定义任务上下文结构，用于在任务切换时保存和恢复 CPU 寄存器状态。
//! 任务上下文包含了任务切换时需要保存的所有寄存器信息。

/// 任务上下文结构
///
/// 存储任务在被切换时的 CPU 寄存器状态。根据 RISC-V 调用约定，
/// 只需要保存调用者保存寄存器 (callee-saved registers)。
///
/// ## 内存布局
///
/// 该结构体使用 `#[repr(C)]` 确保字段按 C 语言结构体布局排列，
/// 这样汇编代码可以通过固定偏移访问各个字段。
///
/// ## 寄存器说明
///
/// - `ra`: 返回地址寄存器，存储函数返回地址
/// - `sp`: 栈指针寄存器，指向当前栈顶
/// - `s0-s11`: 被调用者保存寄存器，需要在函数调用间保持不变
///
/// ## 切换原理
///
/// 在任务切换时：
/// 1. 将当前任务的这些寄存器值保存到其 TaskContext 中
/// 2. 从目标任务的 TaskContext 恢复寄存器值
/// 3. 通过 `ret` 指令跳转到目标任务的 `ra` 地址继续执行
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TaskContext {
    /// 返回地址寄存器 (ra)
    ///
    /// 存储任务恢复执行时应该跳转到的地址。
    /// 对于新创建的任务，通常指向 `__restore` 函数。
    ra: usize,

    /// 栈指针寄存器 (sp)
    ///
    /// 指向任务的内核栈顶。任务切换时会恢复此栈指针，
    /// 确保任务在正确的栈上继续执行。
    sp: usize,

    /// 被调用者保存寄存器 (s0-s11)
    ///
    /// RISC-V 调用约定中的被调用者保存寄存器，函数调用时
    /// 被调用函数需要保证这些寄存器的值不变。
    s: [usize; 12],
}

impl TaskContext {
    /// 创建零初始化的任务上下文
    ///
    /// 创建一个所有寄存器都为零的任务上下文，通常用作临时变量
    /// 或占位符，不代表真实的任务状态。
    ///
    /// ## Returns
    ///
    /// 返回一个所有字段都为 0 的 `TaskContext` 实例
    ///
    /// ## Use Cases
    ///
    /// - 在 `run_first_task` 中作为当前上下文的占位符
    /// - 初始化任务数组时的默认值
    pub fn zero_init() -> Self {
        Self {
            ra: 0,
            sp: 0,
            s: [0; 12],
        }
    }

    /// 创建指向陷阱恢复函数的任务上下文
    ///
    /// 为新创建的任务创建上下文，设置返回地址为 `__restore` 函数，
    /// 栈指针指向指定的内核栈位置。这样当任务被调度时，
    /// 会从 `__restore` 开始执行，恢复用户态并跳转到应用程序入口。
    ///
    /// ## Arguments
    ///
    /// * `kstack_ptr` - 内核栈指针，指向为该任务分配的内核栈顶
    ///
    /// ## Returns
    ///
    /// 返回配置好的 `TaskContext`，可用于任务调度
    ///
    /// ## 执行流程
    ///
    /// 当此上下文被恢复时：
    /// 1. `sp` 被设置为 `kstack_ptr`（内核栈）
    /// 2. 执行 `ret` 跳转到 `__restore` 函数
    /// 3. `__restore` 从内核栈恢复陷阱上下文
    /// 4. `sret` 返回用户态，开始执行应用程序
    ///
    /// ## Safety
    ///
    /// 调用者必须确保：
    /// - `kstack_ptr` 指向有效的内核栈地址
    /// - 内核栈顶包含有效的陷阱上下文
    pub fn goto_restore(kstack_ptr: usize) -> Self {
        unsafe extern "C" {
            fn __restore();
        }
        Self {
            ra: __restore as usize,
            sp: kstack_ptr,
            s: [0; 12],
        }
    }
}
