//! # 陷阱上下文模块
//!
//! 定义陷阱上下文结构，用于在陷阱处理时保存和恢复用户态的完整 CPU 状态。
//! 与进程上下文不同，陷阱上下文保存所有寄存器，确保用户程序状态完整性。

use riscv::register::sstatus::{self, SPP, Sstatus};

/// 陷阱上下文结构
///
/// 保存用户态程序触发陷阱时的完整 CPU 状态，包括所有通用寄存器和
/// 关键的控制状态寄存器 (CSR)。陷阱处理完成后使用此上下文恢复用户态执行。
///
/// ## 内存布局
///
/// 使用 `#[repr(C)]` 确保内存布局与汇编代码兼容：
/// - 通用寄存器 `x0-x31` 按顺序排列（32 × 8 字节）
/// - `sstatus` 寄存器紧随其后（8 字节）
/// - `sepc` 寄存器（8 字节）
/// - `kernel_satp` 内核页表标识符（8 字节）
/// - `kernel_sp` 内核栈指针（8 字节）
/// - `trap_handler` 陷阱处理函数地址（8 字节）
///
/// 总大小：288 字节（36 × 8 字节）
///
/// ## 与进程上下文的区别
///
/// | 对比项 | 陷阱上下文 | 进程上下文 |
/// |--------|------------|------------|
/// | 寄存器数量 | 32个通用寄存器 | 14个被调用者保存寄存器 |
/// | CSR寄存器 | sstatus, sepc | 无 |
/// | 使用场景 | 用户态↔内核态 | 进程切换 |
/// | 保存时机 | 陷阱发生时 | 进程调度时 |
///
/// ## 寄存器说明
///
/// - `x0`: 硬件零寄存器，始终为 0
/// - `x1` (`ra`): 返回地址
/// - `x2` (`sp`): 栈指针
/// - `x3` (`gp`): 全局指针
/// - `x4` (`tp`): 线程指针
/// - `x5-x7` (`t0-t2`): 临时寄存器
/// - `x8-x9` (`s0-s1`): 被调用者保存寄存器
/// - `x10-x11` (`a0-a1`): 函数参数/返回值
/// - `x12-x17` (`a2-a7`): 函数参数
/// - `x18-x27` (`s2-s11`): 被调用者保存寄存器
/// - `x28-x31` (`t3-t6`): 临时寄存器
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct TrapContext {
    /// 通用寄存器 x0-x31
    ///
    /// 保存用户态的所有通用寄存器状态。其中：
    /// - `x[10]` (`a0`) 用于存储系统调用返回值
    /// - `x[10-12]` (`a0-a2`) 用于系统调用参数
    /// - `x[17]` (`a7`) 用于系统调用号
    pub x: [usize; 32],

    /// 监督者状态寄存器 (sstatus)
    ///
    /// 包含处理器状态信息，主要字段包括：
    /// - `SPP`: 先前特权级，记录陷阱前的特权级
    /// - `SPIE`: 先前中断使能，记录陷阱前的中断状态
    /// - `SIE`: 监督者中断使能
    pub sstatus: Sstatus,

    /// 监督者异常程序计数器 (sepc)
    ///
    /// 指向触发陷阱的指令地址。对于：
    /// - **异常**: 指向导致异常的指令
    /// - **中断**: 指向被中断的指令
    /// - **系统调用**: 指向 `ecall` 指令（需要手动 +4 跳过）
    pub sepc: usize,

    /// 内核页表标识符
    ///
    /// 存储内核地址空间的页表标识符，用于在陷阱处理时切换到内核地址空间。
    /// 该值通常是内核页表的 `satp` 寄存器值，包含页表模式和根页表物理页号。
    ///
    /// ## 作用
    ///
    /// 在用户态触发陷阱时，需要切换到内核地址空间来执行陷阱处理代码，
    /// 此字段保存了内核地址空间的页表信息。
    pub kernel_satp: usize,

    /// 内核栈指针
    ///
    /// 存储该进程在内核态执行时使用的栈指针。每个进程都有独立的内核栈，
    /// 用于在陷阱处理时保存寄存器状态和执行内核代码。
    ///
    /// ## 内核栈布局
    ///
    /// 内核栈从高地址向低地址增长，栈顶指向 `TrapContext` 结构体：
    /// ```text
    /// 高地址
    /// ┌─────────────────┐
    /// │   Process Control  │
    /// │     Block       │
    /// ├─────────────────┤ ← kernel_sp 指向这里
    /// │   TrapContext   │
    /// ├─────────────────┤
    /// │  Kernel Stack   │
    /// │     Space       │
    /// └─────────────────┘
    /// 低地址
    /// ```
    pub kernel_sp: usize,

    /// 陷阱处理函数地址
    ///
    /// 存储陷阱处理函数的入口地址，通常指向 `trap_handler` 函数。
    /// 在陷阱发生时，硬件会跳转到此地址开始执行陷阱处理代码。
    ///
    /// ## 陷阱处理流程
    ///
    /// 1. 硬件自动保存部分状态到 CSR 寄存器
    /// 2. 跳转到 `trap_handler` 地址执行
    /// 3. 陷阱处理函数保存完整的用户态上下文
    /// 4. 调用具体的陷阱处理逻辑
    /// 5. 恢复用户态上下文并返回
    pub trap_handler: usize,
}

impl TrapContext {
    /// 设置栈指针寄存器
    ///
    /// 修改用户栈指针 (`sp` 寄存器, `x[2]`)，用于在创建新进程时
    /// 设置用户态栈的位置。
    ///
    /// ## Arguments
    ///
    /// * `sp` - 新的栈指针值，指向用户栈顶
    pub fn sp(&mut self, sp: usize) {
        self.x[2] = sp;
    }

    /// 创建应用程序初始陷阱上下文
    ///
    /// 为新创建的用户应用程序创建初始的陷阱上下文，设置程序入口地址、
    /// 用户栈指针、内核环境信息和适当的处理器状态，使应用程序能够在用户态正确运行。
    ///
    /// ## Arguments
    ///
    /// * `entry` - 应用程序入口地址，通常是应用程序的 `_start` 符号地址
    /// * `sp` - 用户栈指针，指向为该应用程序分配的用户栈顶
    /// * `kernel_satp` - 内核页表标识符，用于陷阱处理时的地址空间切换
    /// * `kernel_sp` - 内核栈指针，指向该进程的内核栈顶
    /// * `trap_handler` - 陷阱处理函数地址，用于处理该进程的陷阱
    ///
    /// ## Returns
    ///
    /// 返回配置好的 `TrapContext`，可以用于首次调度该应用程序
    ///
    /// ## 配置说明
    ///
    /// - **通用寄存器**: 全部初始化为 0
    /// - **栈指针**: 设置为指定的用户栈地址
    /// - **程序计数器**: 设置为应用程序入口地址
    /// - **特权级**: 设置为用户态 (`SPP::User`)
    /// - **内核环境**: 设置内核页表、内核栈和陷阱处理函数
    ///
    /// ## 执行流程
    ///
    /// 当此上下文被 `__restore` 恢复时：
    /// 1. 恢复所有寄存器状态（大部分为 0）
    /// 2. 将 `sepc` 加载到程序计数器
    /// 3. 执行 `sret` 指令跳转到用户态
    /// 4. 开始执行应用程序代码
    ///
    /// ## 陷阱处理准备
    ///
    /// 通过设置 `kernel_satp`、`kernel_sp` 和 `trap_handler`，确保当用户程序
    /// 触发陷阱时能够正确切换到内核环境并执行相应的处理逻辑。
    pub fn app_init_context(
        entry: usize,
        sp: usize,
        kernel_satp: usize,
        kernel_sp: usize,
        trap_handler: usize,
    ) -> Self {
        let mut sstatus = sstatus::read();
        sstatus.set_spp(SPP::User); // 设置返回到用户态
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry, // 设置程序入口地址
            kernel_satp,
            kernel_sp,
            trap_handler,
        };
        cx.sp(sp); // 设置用户栈指针
        cx
    }
}
