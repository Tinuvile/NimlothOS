//! # 栈追踪和调试模块
//!
//! 提供运行时栈追踪功能，用于调试 panic 和异常情况。
//! 通过解析栈帧链表来重构函数调用链，帮助定位问题代码。
//!
//! ## 实现原理
//!
//! ### RISC-V 栈帧结构
//!
//! ```text
//! 高地址 (栈顶)
//! ┌─────────────────┐
//! │   局部变量       │
//! ├─────────────────┤
//! │   saved s0      │ <- fp - 16 (前一个栈帧的 fp)
//! ├─────────────────┤
//! │   saved ra      │ <- fp - 8  (返回地址)
//! ├─────────────────┤ <- 当前 fp (s0)
//! │      ...        │
//! └─────────────────┘
//! 低地址 (栈底)
//! ```
//!
//! ### 追踪过程
//!
//! 1. 从当前的 `s0` 寄存器获取栈帧指针
//! 2. 读取栈帧中保存的返回地址 (`ra`) 和前一个栈帧指针
//! 3. 沿着栈帧链表向上遍历，直到遇到空指针
//! 4. 输出每一级函数调用的地址信息
//!
//! ## 安全注意事项
//!
//! - 栈追踪涉及大量 `unsafe` 指针操作
//! - 在栈损坏或异常情况下可能导致进一步的错误
//! - 当前实现假设栈帧结构符合标准约定

use core::{arch::asm, ptr::null};

use crate::println;

/// 打印函数调用栈追踪信息
///
/// 通过遍历栈帧链表来重构函数调用链，输出每一级调用的地址信息。
/// 主要用于调试 panic 和异常情况，帮助开发者定位问题代码的位置。
///
/// ## 工作原理
///
/// 1. **获取当前栈帧**: 从 `s0` 寄存器读取当前栈帧指针
/// 2. **遍历栈帧链**: 沿着保存的栈帧指针向上遍历
/// 3. **提取地址信息**: 从每个栈帧读取返回地址和前一个栈帧指针
/// 4. **格式化输出**: 将地址信息以十六进制格式输出
///
/// ## 输出格式
///
/// ```text
/// === Call Stack Trace Tool ===
/// 0x0000000080200abc (0x000000008020def0)
/// 0x0000000080201234 (0x000000008020e100)
/// ...
/// === End of Call Stack Trace ===
/// ```
///
/// 每行包含：
/// - 第一个地址：函数返回地址 (ra)，指向调用点之后的指令
/// - 第二个地址：前一个栈帧指针 (fp)
///
/// ## Safety
///
/// 这是一个 `unsafe` 函数，因为它：
/// - 直接访问和解引用栈指针
/// - 假设栈帧结构符合 RISC-V ABI 约定
/// - 在栈损坏的情况下可能导致内存访问错误
///
/// ## 栈帧布局假设
///
/// 该函数假设每个栈帧遵循以下布局：
/// - `fp - 8`: 保存的返回地址 (ra)
/// - `fp - 16`: 保存的前一个栈帧指针 (s0)
///
/// ## 限制
///
/// - 只能追踪使用标准栈帧的函数
/// - 内联函数和优化代码可能不会出现在追踪中
/// - 叶子函数（不调用其他函数）可能没有标准栈帧
/// - 栈指针损坏会导致不准确或危险的输出
///
/// ## Usage
///
/// ```rust
/// // 在 panic 处理程序中使用
/// unsafe {
///     print_stack_trace();
/// }
/// ```
///
/// ## Note
///
/// - 当前该功能在 `lang_items.rs` 中被注释掉，可根据需要启用
/// - 在生产环境中使用时应谨慎，可能影响系统稳定性
/// - 地址信息需要结合符号表或反汇编工具才能转换为具体的函数名
#[allow(dead_code)]
pub unsafe fn print_stack_trace() {
    let mut fp: *const usize;

    // 获取当前栈帧指针 (s0 寄存器)
    unsafe {
        asm!("mv {}, s0", out(reg) fp);
    }

    println!("=== Call Stack Trace Tool ===");

    // 遍历栈帧链表
    while fp != null() {
        // 从栈帧中读取保存的返回地址和前一个栈帧指针
        unsafe {
            let saved_ra = *fp.sub(1); // fp - 8 字节处的返回地址
            let saved_fp = *fp.sub(2); // fp - 16 字节处的栈帧指针

            println!("0x{:016x} (0x{:016x})", saved_ra, saved_fp);

            // 移动到前一个栈帧
            fp = saved_fp as *const usize;
        }
    }

    println!("=== End of Call Stack Trace ===");
}
