//! # 文件系统模块
//!
//! 提供操作系统内核的文件系统抽象层，包括文件操作接口、inode 管理、
//! 标准输入输出等功能。为上层应用提供统一的文件访问接口。
//!
//! ## 模块组织
//!
//! - [`inode`] - 文件 inode 管理，提供文件读写和元数据操作
//! - [`stdio`] - 标准输入输出设备，包括 stdin 和 stdout
//!
//! ## 设计目标
//!
//! - **统一接口**: 为不同类型的文件提供统一的 `File` trait 接口
//! - **类型安全**: 通过 trait 约束确保文件操作的类型安全
//! - **并发支持**: 支持多线程并发访问文件
//! - **抽象层次**: 屏蔽底层文件系统的复杂性
//!
//! ## 核心组件
//!
//! ### 文件接口
//! - [`File`] - 文件抽象 trait，定义基本的文件操作
//! - [`inode::OSInode`] - 操作系统级别的 inode 封装
//! - [`Stdin`] / [`Stdout`] - 标准输入输出设备
//!
//! ### 文件操作
//! - [`open_file`] - 打开文件的统一接口
//! - [`list_apps`] - 列出应用程序列表
//! - [`OpenFlags`] - 文件打开标志位
//!
//! ## 文件系统特性
//!
//! - **多种文件类型**: 支持普通文件、目录、设备文件等
//! - **权限控制**: 支持读写权限的独立控制
//! - **位置管理**: 支持文件偏移量的自动管理
//! - **缓冲优化**: 支持用户缓冲区的批量处理
//!
//! ## 使用示例
//!
//! ```rust
//! use crate::fs::{File, open_file, OpenFlags};
//!
//! // 打开文件进行读写
//! let file = open_file("test.txt", OpenFlags::RDWR).unwrap();
//!
//! // 读取文件内容
//! let mut buf = [0u8; 1024];
//! let user_buf = UserBuffer::new(&mut buf);
//! let bytes_read = file.read(user_buf);
//!
//! // 写入文件内容
//! let data = b"Hello, World!";
//! let user_buf = UserBuffer::new(data);
//! let bytes_written = file.write(user_buf);
//! ```

use crate::mm::UserBuffer;

mod inode;
mod pipe;
mod stdio;

pub use inode::{OpenFlags, list_apps, open_file};
pub use pipe::make_pipe;
pub use stdio::{Stderr, Stdin, Stdout};

/// 文件抽象接口
///
/// 定义文件的基本操作接口，为不同类型的文件提供统一的抽象。
/// 该 trait 是文件系统抽象层的核心，支持普通文件、设备文件等各种文件类型。
///
/// ## 实现要求
///
/// 实现者需要确保：
/// - **线程安全**: 支持多线程并发访问
/// - **原子操作**: 单个读写操作应该是原子的
/// - **错误处理**: 在文件错误时应该有适当的错误处理机制
/// - **权限检查**: 根据文件权限正确实现读写操作
///
/// ## 文件操作语义
///
/// - `read`: 从文件读取数据到用户缓冲区
/// - `write`: 将用户缓冲区数据写入文件
/// - `readable` / `writable`: 检查文件的读写权限
///
/// ## 性能考虑
///
/// - 实现应该尽可能减少内存拷贝
/// - 支持批量操作以提高性能
/// - 考虑缓存策略以优化频繁访问的文件
///
/// ## 注意事项
///
/// - 缓冲区大小应该合理，避免过大的内存分配
/// - 实现应该处理边界情况和错误状态
/// - 写入操作可能需要考虑持久化策略
pub trait File: Send + Sync {
    /// 从文件读取数据
    ///
    /// 将文件中的数据读取到提供的用户缓冲区中。该操作是原子的，
    /// 要么读取请求的数据，要么返回已读取的字节数。
    ///
    /// ## Arguments
    /// * `buf` - 用户缓冲区，用于存储读取的数据
    ///
    /// ## Returns
    /// 实际读取的字节数，0 表示已到达文件末尾
    ///
    /// ## 行为
    /// - 从当前文件偏移量开始读取数据
    /// - 将数据写入提供的用户缓冲区
    /// - 更新文件偏移量
    /// - 返回实际读取的字节数
    ///
    /// ## 错误处理
    /// - 如果文件不可读，行为由具体实现定义
    /// - 如果缓冲区为空，返回 0
    /// - 如果到达文件末尾，返回 0
    fn read(&self, buf: UserBuffer) -> usize;

    /// 向文件写入数据
    ///
    /// 将用户缓冲区中的数据写入文件。该操作是原子的，
    /// 要么完全写入成功，要么返回已写入的字节数。
    ///
    /// ## Arguments
    /// * `buf` - 用户缓冲区，包含要写入的数据
    ///
    /// ## Returns
    /// 实际写入的字节数
    ///
    /// ## 行为
    /// - 从当前文件偏移量开始写入数据
    /// - 将用户缓冲区数据写入文件
    /// - 更新文件偏移量
    /// - 返回实际写入的字节数
    ///
    /// ## 错误处理
    /// - 如果文件不可写，行为由具体实现定义
    /// - 如果缓冲区为空，返回 0
    /// - 如果磁盘空间不足，返回已写入的字节数
    fn write(&self, buf: UserBuffer) -> usize;

    /// 检查文件是否可读
    ///
    /// ## Returns
    /// 如果文件可读返回 `true`，否则返回 `false`
    fn readable(&self) -> bool;

    /// 检查文件是否可写
    ///
    /// ## Returns
    /// 如果文件可写返回 `true`，否则返回 `false`
    fn writable(&self) -> bool;
}
