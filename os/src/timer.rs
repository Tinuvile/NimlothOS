//! # 时钟和定时器管理模块
//!
//! 提供系统时间读取和定时器管理功能，支持抢占式多任务调度的时间片机制。
//! 基于 RISC-V 的 `time` CSR 寄存器和 SBI 时钟接口实现。
//!
//! ## 核心功能
//!
//! - **时间读取**: 获取系统启动以来的时钟周期数和毫秒数
//! - **定时器设置**: 配置下一次时钟中断的触发时间
//! - **时间片调度**: 支持基于时间片的抢占式任务调度
//!
//! ## 时钟配置
//!
//! - **时钟频率**: 由 [`CLOCK_FREQ`] 定义，通常为 12.5MHz (QEMU 环境)
//! - **时间片频率**: 100Hz，即每 10ms 触发一次时钟中断
//! - **时间精度**: 毫秒级时间测量精度
//!
//! ## 使用场景
//!
//! - 任务调度的时间片管理
//! - 系统调用 `get_time()` 的实现
//! - 性能测量和基准测试
//! - 超时和延迟功能

use crate::config::CLOCK_FREQ;
use crate::sbi::timer;
use riscv::register::time;

/// 每秒的时钟中断次数 (100Hz)
///
/// 定义抢占式调度的时间片频率。100Hz 意味着每 10 毫秒触发一次
/// 时钟中断，提供良好的响应性和合理的调度开销。
const TICKS_PER_SEC: usize = 100;

/// 每秒的毫秒数常量
const MSEC_PER_SEC: usize = 1000;

/// 获取当前系统时间（时钟周期数）
///
/// 返回系统启动以来的时钟周期数，用于时间测量和定时器功能。
/// 时钟频率由 `CLOCK_FREQ` 常量定义。
///
/// ## Returns
///
/// 系统启动以来的时钟周期数
///
/// ## Examples
///
/// ```
/// let start = time();
/// // ... 执行一些操作 ...
/// let end = time();
/// let elapsed = end - start;
/// ```
pub fn time() -> usize {
    riscv::register::time::read()
}

/// 获取当前系统时间（毫秒）
///
/// 将时钟周期数转换为毫秒，便于人类理解的时间表示。
/// 转换公式：毫秒 = 时钟周期数 / (时钟频率 / 1000)
///
/// ## Returns
///
/// 系统启动以来的毫秒数
///
/// ## Examples
///
/// ```
/// let start_ms = time_ms();
/// // ... 执行一些操作 ...
/// let end_ms = time_ms();
/// let elapsed_ms = end_ms - start_ms;
/// ```
pub fn time_ms() -> usize {
    time() / (CLOCK_FREQ / 1000)
}

/// 设置下一次时钟中断触发时间
///
/// 配置时钟设备在当前时间基础上加一个时间片间隔后触发中断，
/// 实现定期的抢占式任务调度。
///
/// ## 工作原理
///
/// 1. 获取当前时间 (`time()`)
/// 2. 计算下次中断时间：当前时间 + 时间片间隔
/// 3. 通过 SBI 接口设置时钟中断触发时间
/// 4. 当时钟到达设定时间时，硬件触发时钟中断
///
/// ## 时间片计算
///
/// 时间片间隔 = `CLOCK_FREQ / TICKS_PER_SEC`
/// - 在 12.5MHz 时钟下，间隔为 125,000 个时钟周期
/// - 对应 10 毫秒的时间片长度
///
/// ## Usage
///
/// 该函数通常在以下时机调用：
/// - 系统初始化时设置第一次时钟中断
/// - 时钟中断处理程序中设置下一次中断
///
/// ## Note
///
/// 必须在每次时钟中断处理时调用此函数，否则时钟中断将不会再次触发。
pub fn next_trigger() {
    timer(time() + CLOCK_FREQ / TICKS_PER_SEC);
}
