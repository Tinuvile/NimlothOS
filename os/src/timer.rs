//! # 时钟和定时器管理模块
//!
//! 提供系统时间读取和定时器管理功能，支持抢占式多任务调度的时间片机制。
//! 基于 RISC-V 的 `time` CSR 寄存器和 SBI 时钟接口实现。
//!
//! ## 核心功能
//!
//! - **时间读取**: 获取系统启动以来的时钟周期数和毫秒数
//! - **定时器设置**: 配置下一次时钟中断的触发时间
//! - **时间片调度**: 支持基于时间片的抢占式任务调度
//!
//! ## 时钟配置
//!
//! - **时钟频率**: 由 [`CLOCK_FREQ`] 定义，通常为 12.5MHz (QEMU 环境)
//! - **时间片频率**: 100Hz，即每 10ms 触发一次时钟中断
//! - **时间精度**: 毫秒级时间测量精度
//!
//! ## 使用场景
//!
//! - 任务调度的时间片管理
//! - 系统调用 `get_time()` 的实现
//! - 性能测量和基准测试
//! - 超时和延迟功能

use crate::config::CLOCK_FREQ;
use crate::sbi::set_timer;
use riscv::register::time;

/// 每秒的时钟中断次数 (100Hz)
///
/// 定义抢占式调度的时间片频率。100Hz 意味着每 10 毫秒触发一次
/// 时钟中断，提供良好的响应性和合理的调度开销。
const TICKS_PER_SEC: usize = 100;

/// 每秒的毫秒数常量
const MSEC_PER_SEC: usize = 1000;

/// 获取系统时间（时钟周期）
///
/// 读取 RISC-V 的 `time` CSR 寄存器，返回自系统启动以来经过的
/// 时钟周期数。这是最精确的时间测量方式。
///
/// ## Returns
///
/// 返回时钟周期计数，单位为时钟周期（通常为纳秒级精度）
///
/// ## Usage
///
/// ```rust
/// let start = get_time();
/// // 执行某些操作
/// let end = get_time();
/// let cycles = end - start;  // 经过的时钟周期数
/// ```
///
/// ## Note
///
/// 时钟周期数会在长时间运行后溢出，但对于大多数应用场景足够使用。
pub fn get_time() -> usize {
    time::read()
}

/// 获取系统时间（毫秒）
///
/// 将时钟周期数转换为毫秒，提供更直观的时间测量单位。
/// 转换基于系统时钟频率 [`CLOCK_FREQ`] 进行。
///
/// ## Returns
///
/// 返回自系统启动以来经过的毫秒数
///
/// ## Precision
///
/// 精度取决于时钟频率和整数除法的舍入误差，通常为毫秒级精度。
///
/// ## Usage
///
/// ```rust
/// let start_ms = get_time_ms();
/// // 执行某些操作
/// let end_ms = get_time_ms();
/// let elapsed_ms = end_ms - start_ms;  // 经过的毫秒数
/// ```
///
/// ## Implementation
///
/// 通过除法 `time / (CLOCK_FREQ / MSEC_PER_SEC)` 将时钟周期转换为毫秒。
/// 这等价于 `(time * MSEC_PER_SEC) / CLOCK_FREQ`，但避免了大数乘法的溢出风险。
pub fn get_time_ms() -> usize {
    time::read() / (CLOCK_FREQ / MSEC_PER_SEC)
}

/// 设置下一次时钟中断触发时间
///
/// 配置时钟设备在当前时间基础上加一个时间片间隔后触发中断，
/// 实现定期的抢占式任务调度。
///
/// ## 工作原理
///
/// 1. 获取当前时间 (`get_time()`)
/// 2. 计算下次中断时间：当前时间 + 时间片间隔
/// 3. 通过 SBI 接口设置时钟中断触发时间
/// 4. 当时钟到达设定时间时，硬件触发时钟中断
///
/// ## 时间片计算
///
/// 时间片间隔 = `CLOCK_FREQ / TICKS_PER_SEC`
/// - 在 12.5MHz 时钟下，间隔为 125,000 个时钟周期
/// - 对应 10 毫秒的时间片长度
///
/// ## Usage
///
/// 该函数通常在以下时机调用：
/// - 系统初始化时设置第一次时钟中断
/// - 时钟中断处理程序中设置下一次中断
///
/// ## Note
///
/// 必须在每次时钟中断处理时调用此函数，否则时钟中断将不会再次触发。
pub fn set_next_trigger() {
    set_timer(get_time() + CLOCK_FREQ / TICKS_PER_SEC);
}
