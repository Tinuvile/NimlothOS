//! # 进程上下文切换
//!
//! 提供底层的进程上下文切换功能，通过汇编代码实现高效的寄存器状态保存和恢复。

use super::context::ProcessContext;
use core::arch::global_asm;

// 包含汇编实现的进程切换代码
global_asm!(include_str!("switch.S"));

unsafe extern "C" {
    /// 执行进程上下文切换
    ///
    /// 这是进程调度的核心底层函数，负责保存当前进程的 CPU 寄存器状态
    /// 并恢复目标进程的寄存器状态，实现进程间的切换。
    ///
    /// ## 功能
    ///
    /// 1. **保存当前上下文**: 将当前进程的寄存器状态保存到 `current_process_cx_ptr` 指向的结构体
    /// 2. **恢复目标上下文**: 从 `next_process_cx_ptr` 指向的结构体恢复目标进程的寄存器状态
    /// 3. **执行切换**: 通过 `ret` 指令跳转到目标进程继续执行
    ///
    /// ## Arguments
    ///
    /// * `current_process_cx_ptr` - 指向当前进程上下文的可变指针，用于保存当前状态
    /// * `next_process_cx_ptr` - 指向目标进程上下文的只读指针，用于恢复目标进程状态
    ///
    /// ## Safety
    ///
    /// 这是一个 `unsafe` 函数，调用者必须确保：
    ///
    /// - 两个指针都指向有效的 `ProcessContext` 结构体
    /// - `current_process_cx_ptr` 指向的内存可以安全写入
    /// - 调用时处于适当的执行环境（通常在内核态）
    /// - 目标进程的上下文是有效的，包含正确的栈指针和返回地址
    ///
    /// ## 调用约定
    ///
    /// 遵循 RISC-V C 调用约定：
    /// - `a0` 寄存器传递 `current_process_cx_ptr`
    /// - `a1` 寄存器传递 `next_process_cx_ptr`
    /// - 函数不返回到调用点，而是跳转到目标进程执行
    ///
    /// ## 实现细节
    ///
    /// 该函数在 `switch.S` 中用汇编语言实现，主要包含：
    ///
    /// 1. **保存阶段**:
    ///    - 保存返回地址 (`ra`) 到当前上下文
    ///    - 保存栈指针 (`sp`) 到当前上下文
    ///    - 保存所有被调用者保存寄存器 (`s0-s11`) 到当前上下文
    ///
    /// 2. **恢复阶段**:
    ///    - 从目标上下文恢复返回地址 (`ra`)
    ///    - 从目标上下文恢复所有被调用者保存寄存器 (`s0-s11`)
    ///    - 从目标上下文恢复栈指针 (`sp`)
    ///
    /// 3. **跳转阶段**:
    ///    - 执行 `ret` 指令跳转到目标进程的 `ra` 地址
    ///
    /// ## 注意事项
    ///
    /// - 此函数执行后不会返回到原调用点
    /// - 当前进程会在将来被重新调度时从此处恢复执行
    /// - 函数执行期间中断应该被禁用，避免调度状态不一致
    pub unsafe fn __switch(
        current_process_cx_ptr: *mut ProcessContext,
        next_process_cx_ptr: *const ProcessContext,
    );
}
