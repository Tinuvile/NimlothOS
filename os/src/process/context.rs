//! # 进程上下文模块
//!
//! 定义进程上下文结构，用于在进程切换时保存和恢复 CPU 寄存器状态。
//! 进程上下文包含了进程切换时需要保存的所有寄存器信息。
use crate::trap::trap_return;

/// 进程上下文结构
///
/// 存储进程在被切换时的 CPU 寄存器状态。根据 RISC-V 调用约定，
/// 只需要保存调用者保存寄存器 (callee-saved registers)。
///
/// ## 内存布局
///
/// 该结构体使用 `#[repr(C)]` 确保字段按 C 语言结构体布局排列，
/// 这样汇编代码可以通过固定偏移访问各个字段。
///
/// ## 寄存器说明
///
/// - `ra`: 返回地址寄存器，存储函数返回地址
/// - `sp`: 栈指针寄存器，指向当前栈顶
/// - `s0-s11`: 被调用者保存寄存器，需要在函数调用间保持不变
///
/// ## 切换原理
///
/// 在进程切换时：
/// 1. 将当前进程的这些寄存器值保存到其 ProcessContext 中
/// 2. 从目标进程的 ProcessContext 恢复寄存器值
/// 3. 通过 `ret` 指令跳转到目标进程的 `ra` 地址继续执行
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ProcessContext {
    /// 返回地址寄存器 (ra)
    ///
    /// 存储进程恢复执行时应该跳转到的地址。
    /// 对于新创建的进程，通常指向 `__restore` 函数。
    ra: usize,

    /// 栈指针寄存器 (sp)
    ///
    /// 指向进程的内核栈顶。进程切换时会恢复此栈指针，
    /// 确保进程在正确的栈上继续执行。
    sp: usize,

    /// 被调用者保存寄存器 (s0-s11)
    ///
    /// RISC-V 调用约定中的被调用者保存寄存器，函数调用时
    /// 被调用函数需要保证这些寄存器的值不变。
    s: [usize; 12],
}

impl ProcessContext {
    /// 创建零初始化的进程上下文
    ///
    /// 创建一个所有寄存器都为零的进程上下文，通常用作临时变量
    /// 或占位符，不代表真实的进程状态。
    ///
    /// ## Returns
    ///
    /// 返回一个所有字段都为 0 的 `ProcessContext` 实例
    ///
    /// ## Use Cases
    ///
    /// - 在 `run_first_process` 中作为当前上下文的占位符
    /// - 初始化进程数组时的默认值
    pub fn zero_init() -> Self {
        Self {
            ra: 0,
            sp: 0,
            s: [0; 12],
        }
    }

    /// 创建指向陷阱返回的进程上下文
    ///
    /// 为新进程创建一个进程上下文，设置返回地址指向 `trap_return` 函数。
    /// 这使得当进程首次被调度时，会跳转到 `trap_return` 执行，从而
    /// 恢复陷阱上下文并进入用户态开始执行。
    ///
    /// ## Arguments
    ///
    /// * `kstack_ptr` - 内核栈指针，指向该进程的内核栈顶
    ///
    /// ## Returns
    ///
    /// 配置好的进程上下文，可用于进程首次调度
    ///
    /// ## 执行流程
    ///
    /// 当此上下文被 `__switch` 恢复时：
    /// 1. 恢复栈指针到指定的内核栈
    /// 2. 通过 `ret` 指令跳转到 `trap_return` 函数
    /// 3. `trap_return` 恢复陷阱上下文并切换到用户态
    /// 4. 用户程序开始执行
    ///
    /// ## 与 `zero_init()` 的区别
    ///
    /// | 方法 | 返回地址 | 用途 |
    /// |------|----------|------|
    /// | `zero_init()` | 0 | 临时占位符 |
    /// | `goto_trap_return()` | `trap_return` | 新进程初始化 |
    ///
    /// ## 设计原理
    ///
    /// 新创建的进程需要一个特殊的启动流程：
    /// - 不能直接跳转到用户代码（缺少完整的用户态上下文）
    /// - 必须通过 `trap_return` 建立完整的用户态环境
    /// - 这种设计统一了进程切换和陷阱返回的机制
    ///
    /// ## Examples
    ///
    /// ```rust
    /// // 为新进程创建上下文
    /// let process_cx = ProcessContext::goto_trap_return(kernel_stack_top);
    ///
    /// // 进程首次调度时的执行路径：
    /// // __switch -> trap_return -> __restore -> 用户程序
    /// ```
    pub fn goto_trap_return(kstack_ptr: usize) -> Self {
        Self {
            ra: trap_return as usize,
            sp: kstack_ptr,
            s: [0; 12],
        }
    }
}
