//! # 块设备抽象模块
//!
//! 提供块设备的抽象接口，定义了块设备的基本操作。块设备是文件系统的基础，
//! 提供了以块为单位的读写操作，支持多种存储介质的统一抽象。
//!
//! ## 设计目标
//!
//! - **统一接口**：为不同的块设备实现提供统一的抽象接口
//! - **类型安全**：通过 trait 约束确保类型安全和线程安全
//! - **性能优化**：支持高效的块级读写操作
//! - **扩展性**：支持内存块设备、磁盘块设备等多种实现
//!
//! ## 核心组件
//!
//! - [`BlockDevice`] - 块设备抽象 trait，定义了块设备的基本操作
//!
//! ## 块设备特性
//!
//! - **块大小固定**：所有块设备使用相同的块大小（通常为 4KB）
//! - **随机访问**：支持任意块 ID 的读写操作
//! - **原子操作**：单个块的读写操作是原子的
//! - **线程安全**：支持多线程并发访问
//!
//! ## 使用示例
//!
//! ```rust
//! use micro_fs::BlockDevice;
//!
//! // 实现内存块设备
//! struct MemoryBlockDevice {
//!     blocks: Vec<Vec<u8>>,
//! }
//!
//! impl BlockDevice for MemoryBlockDevice {
//!     fn read_block(&self, block_id: usize, buf: &mut [u8]) {
//!         if let Some(block) = self.blocks.get(block_id) {
//!             buf.copy_from_slice(&block[..buf.len()]);
//!         }
//!     }
//!     
//!     fn write_block(&self, block_id: usize, buf: &[u8]) {
//!         if let Some(block) = self.blocks._mut(block_id) {
//!             block[..buf.len()].copy_from_slice(buf);
//!         }
//!     }
//! }
//! ```
//!

use core::any::Any;

/// 块设备抽象接口
///
/// 定义了块设备的基本操作，包括块读取和块写入。块设备是文件系统的底层存储
/// 抽象，提供了以固定大小块为单位的随机访问能力。
///
/// ## 特性约束
///
/// - `Send` - 可以在线程间安全传递，支持跨线程使用
/// - `Sync` - 可以在线程间安全共享引用，支持并发访问
/// - `Any` - 支持运行时类型检查和动态分发
///
/// ## 实现要求
///
/// 实现者需要确保：
/// - **块大小一致**：所有块的读写操作都使用相同的块大小
/// - **原子性**：单个块的读写操作应该是原子的，要么完全成功，要么完全失败
/// - **错误处理**：在设备错误时应该有适当的错误处理机制
/// - **边界检查**：正确处理无效的块 ID 和缓冲区大小不匹配的情况
///
/// ## 块操作语义
///
/// - `read_block`: 从指定块读取数据到缓冲区
/// - `write_block`: 将缓冲区数据写入指定块
///
/// ## 性能考虑
///
/// - 实现应该尽可能减少内存拷贝
/// - 支持批量操作以提高性能
/// - 考虑缓存策略以优化频繁访问的块
///
/// ## 注意事项
///
/// - 块 ID 的有效范围由具体实现决定
/// - 缓冲区大小应该与块大小匹配以获得最佳性能
/// - 实现应该处理边界情况和错误状态
/// - 写入操作可能需要考虑持久化策略
pub trait BlockDevice: Send + Sync + Any {
    /// 从指定块读取数据
    ///
    /// 将块设备中指定块的数据读取到提供的缓冲区中。该操作是原子的，
    /// 要么读取整个块的数据，要么失败。
    ///
    /// ## Arguments
    /// * `block_id` - 要读取的块 ID，由实现定义有效范围
    /// * `buf` - 用于存储读取数据的缓冲区
    ///
    /// ## 行为
    /// - 从块设备读取整个块的数据
    /// - 将数据写入提供的缓冲区
    /// - 如果缓冲区大小小于块大小，只读取缓冲区能容纳的数据
    /// - 如果缓冲区大小大于块大小，多余部分保持不变
    ///
    /// ## 错误处理
    /// - 如果块 ID 无效，行为由具体实现定义（可能 panic 或静默失败）
    /// - 如果设备不可用，应该通过 panic 或其他方式报告错误
    /// - 读取失败时缓冲区内容未定义
    ///
    /// ## 性能说明
    /// - 实现应该尽可能避免不必要的内存拷贝
    /// - 可以考虑缓存机制以提高频繁访问块的性能
    fn read_block(&self, block_id: usize, buf: &mut [u8]);

    /// 向指定块写入数据
    ///
    /// 将缓冲区中的数据写入块设备中的指定块。该操作是原子的，
    /// 要么完全写入成功，要么完全失败。
    ///
    /// ## Arguments
    /// * `block_id` - 要写入的块 ID，由实现定义有效范围
    /// * `buf` - 包含要写入数据的缓冲区
    ///
    /// ## 行为
    /// - 将缓冲区数据写入指定的块
    /// - 如果缓冲区大小小于块大小，块中未覆盖的部分保持不变
    /// - 如果缓冲区大小大于块大小，只写入块能容纳的数据
    /// - 写入操作完成后，数据立即可用于后续的读取操作
    ///
    /// ## 错误处理
    /// - 如果块 ID 无效，行为由具体实现定义
    /// - 如果设备不可写或不可用，应该通过 panic 或其他方式报告错误
    /// - 写入操作应该是原子的，要么完全成功，要么完全失败
    /// - 写入失败时块的内容应该保持不变
    ///
    /// ## 持久化
    /// - 实现应该确保写入的数据在系统重启后仍然可用
    /// - 可能需要考虑写入缓存和刷新策略
    /// - 对于内存块设备，持久化行为由实现定义
    fn write_block(&self, block_id: usize, buf: &[u8]);
}
