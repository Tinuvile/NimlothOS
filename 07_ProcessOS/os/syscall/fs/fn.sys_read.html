<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="系统调用：从文件描述符读取数据"><title>sys_read in os::syscall::fs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="os" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (ce36a966c 2025-02-17)" data-channel="nightly" data-search-js="search-f7327375.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5332ae0c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../os/index.html">os</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">sys_<wbr>read</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#arguments" title="Arguments">Arguments</a></li><li><a href="#returns" title="Returns">Returns</a></li><li><a href="#实现限制" title="实现限制">实现限制</a></li><li><a href="#阻塞机制" title="阻塞机制">阻塞机制</a><ul><li><a href="#字符读取逻辑" title="字符读取逻辑">字符读取逻辑</a></li><li><a href="#任务调度协作" title="任务调度协作">任务调度协作</a></li></ul></li><li><a href="#内存管理" title="内存管理">内存管理</a><ul><li><a href="#地址转换安全性" title="地址转换安全性">地址转换安全性</a></li><li><a href="#内存写入" title="内存写入">内存写入</a></li></ul></li><li><a href="#使用场景" title="使用场景">使用场景</a><ul><li><a href="#键盘输入处理" title="键盘输入处理">键盘输入处理</a></li><li><a href="#交互式程序" title="交互式程序">交互式程序</a></li></ul></li><li><a href="#safety" title="Safety">Safety</a><ul><li><a href="#内存安全" title="内存安全">内存安全</a></li><li><a href="#并发安全" title="并发安全">并发安全</a></li></ul></li><li><a href="#限制和待优化" title="限制和待优化">限制和待优化</a></li><li><a href="#panics" title="Panics">Panics</a></li><li><a href="#examples" title="Examples">Examples</a><ul><li><a href="#c-风格调用" title="C 风格调用">C 风格调用</a></li><li><a href="#在系统调用处理中" title="在系统调用处理中">在系统调用处理中</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In os::<wbr>syscall::<wbr>fs</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">os</a>::<wbr><a href="../index.html">syscall</a>::<wbr><a href="index.html">fs</a></div><h1>Function <span class="fn">sys_read</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/os/syscall/fs.rs.html#208-233">Source</a> </span></div><pre class="rust item-decl"><code>pub fn sys_read(fd: usize, buf: *const u8, len: usize) -&gt; isize</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>系统调用：从文件描述符读取数据</p>
<p>实现 <code>read(2)</code> 系统调用，从指定的文件描述符中读取数据。
当前实现只支持从标准输入 (stdin) 读取单个字符。</p>
<h3 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h3>
<ul>
<li><code>fd</code> - 文件描述符，当前只支持 <code>FD_STDIN</code> (0)</li>
<li><code>buf</code> - 指向接收数据的缓冲区指针</li>
<li><code>len</code> - 要读取的字节数，当前限制为 1</li>
</ul>
<h3 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h3>
<ul>
<li>成功时返回实际读取的字节数 (当前总是返回 1)</li>
<li>失败时会 panic (暂未实现错误码返回)</li>
</ul>
<h3 id="实现限制"><a class="doc-anchor" href="#实现限制">§</a>实现限制</h3>
<p>当前实现有以下限制：</p>
<ul>
<li><strong>单字符读取</strong>: 只支持 <code>len = 1</code>，即每次只能读取一个字符</li>
<li><strong>仅支持 stdin</strong>: 只能从标准输入文件描述符 (0) 读取</li>
<li><strong>阻塞读取</strong>: 如果没有输入字符，会挂起当前任务等待输入</li>
</ul>
<h3 id="阻塞机制"><a class="doc-anchor" href="#阻塞机制">§</a>阻塞机制</h3><h4 id="字符读取逻辑"><a class="doc-anchor" href="#字符读取逻辑">§</a>字符读取逻辑</h4>
<ul>
<li>调用 <code>console_getchar()</code> 尝试读取字符</li>
<li>如果返回 0 (无字符可读)，挂起当前任务并切换到其他任务</li>
<li>当有字符输入时，任务被重新调度，继续读取</li>
<li>读取到有效字符后跳出循环</li>
</ul>
<h4 id="任务调度协作"><a class="doc-anchor" href="#任务调度协作">§</a>任务调度协作</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    c = console_getchar();
    <span class="kw">if </span>c == <span class="number">0 </span>{
        suspend_current_and_run_next();  <span class="comment">// 让出 CPU
        </span><span class="kw">continue</span>;                        <span class="comment">// 被调度回来时继续尝试
    </span>} <span class="kw">else </span>{
        <span class="kw">break</span>;                          <span class="comment">// 成功读取字符
    </span>}
}</code></pre></div>
<h3 id="内存管理"><a class="doc-anchor" href="#内存管理">§</a>内存管理</h3><h4 id="地址转换安全性"><a class="doc-anchor" href="#地址转换安全性">§</a>地址转换安全性</h4>
<ul>
<li>使用 <code>current_user_token()</code> 获取当前任务的页表</li>
<li>通过 <code>translated_byte_buffer()</code> 安全地访问用户内存</li>
<li>支持跨页面的缓冲区（虽然当前只读取1字节）</li>
</ul>
<h4 id="内存写入"><a class="doc-anchor" href="#内存写入">§</a>内存写入</h4>
<ul>
<li>使用 <code>write_volatile()</code> 确保写入操作不被编译器优化</li>
<li>直接写入用户提供的缓冲区的第一个字节</li>
</ul>
<h3 id="使用场景"><a class="doc-anchor" href="#使用场景">§</a>使用场景</h3><h4 id="键盘输入处理"><a class="doc-anchor" href="#键盘输入处理">§</a>键盘输入处理</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 用户态代码
</span>char ch;
read(<span class="number">0</span>, <span class="kw-2">&amp;</span>ch, <span class="number">1</span>);  <span class="comment">// 从键盘读取一个字符
</span>printf(<span class="string">"You typed: %c\n"</span>, ch);</code></pre></div>
<h4 id="交互式程序"><a class="doc-anchor" href="#交互式程序">§</a>交互式程序</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 简单的交互循环
</span><span class="kw">loop </span>{
    <span class="macro">print!</span>(<span class="string">"Enter a character: "</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = [<span class="number">0u8</span>; <span class="number">1</span>];
    read(<span class="number">0</span>, buffer.as_mut_ptr(), <span class="number">1</span>);
    <span class="kw">if </span>buffer[<span class="number">0</span>] == <span class="string">b'q' </span>{
        <span class="kw">break</span>;  <span class="comment">// 输入 'q' 退出
    </span>}
    <span class="macro">println!</span>(<span class="string">"You entered: {}"</span>, buffer[<span class="number">0</span>] <span class="kw">as </span>char);
}</code></pre></div>
<h3 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h3><h4 id="内存安全"><a class="doc-anchor" href="#内存安全">§</a>内存安全</h4>
<ul>
<li>通过页表转换验证用户地址的有效性</li>
<li>使用 <code>write_volatile</code> 防止编译器优化导致的问题</li>
<li>确保只写入用户任务有权访问的内存</li>
</ul>
<h4 id="并发安全"><a class="doc-anchor" href="#并发安全">§</a>并发安全</h4>
<ul>
<li>阻塞读取通过任务调度实现，不会阻塞整个系统</li>
<li>任务挂起和恢复由调度器安全管理</li>
</ul>
<h3 id="限制和待优化"><a class="doc-anchor" href="#限制和待优化">§</a>限制和待优化</h3>
<ol>
<li><strong>单字符限制</strong>: 每次只能读取一个字符，效率较低</li>
<li><strong>错误处理</strong>: 当前使用 panic，应该返回适当的错误码</li>
<li><strong>缓冲支持</strong>: 未来可以支持读取多个字符到缓冲区</li>
<li><strong>文件系统</strong>: 目前只支持控制台输入，不支持文件读取</li>
</ol>
<h3 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h3>
<ul>
<li>当 <code>len != 1</code> 时会 panic</li>
<li>当 <code>fd</code> 不是 <code>FD_STDIN</code> 时会 panic</li>
<li>当用户提供的虚拟地址无效时，地址转换可能会 panic</li>
</ul>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3><h4 id="c-风格调用"><a class="doc-anchor" href="#c-风格调用">§</a>C 风格调用</h4><div class="example-wrap"><pre class="language-c"><code>char buffer;
ssize_t result = read(0, &amp;buffer, 1);  // 从 stdin 读取一个字符
if (result == 1) {
    printf(&quot;Read character: %c\n&quot;, buffer);
}</code></pre></div><h4 id="在系统调用处理中"><a class="doc-anchor" href="#在系统调用处理中">§</a>在系统调用处理中</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>syscall(syscall_id: usize, args: [usize; <span class="number">3</span>]) -&gt; isize {
    <span class="kw">match </span>syscall_id {
        SYSCALL_READ =&gt; sys_read(args[<span class="number">0</span>], args[<span class="number">1</span>] <span class="kw">as </span><span class="kw-2">*const </span>u8, args[<span class="number">2</span>]),
        <span class="comment">// ...
    </span>}
}</code></pre></div>
</div></details></section></div></main></body></html>