<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="处理器状态管理器"><title>Processor in os::process::processor - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="os" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (ce36a966c 2025-02-17)" data-channel="nightly" data-search-js="search-f7327375.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5332ae0c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../os/index.html">os</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Processor</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#设计原理" title="设计原理">设计原理</a><ul><li><a href="#双上下文模型" title="双上下文模型">双上下文模型</a></li><li><a href="#所有权管理" title="所有权管理">所有权管理</a></li></ul></li><li><a href="#状态转换" title="状态转换">状态转换</a></li><li><a href="#内存布局" title="内存布局">内存布局</a></li><li><a href="#并发安全" title="并发安全">并发安全</a></li><li><a href="#性能特征" title="性能特征">性能特征</a></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.current" title="current">current</a></li><li><a href="#structfield.idle_process_cx" title="idle_process_cx">idle_process_cx</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.current" title="current">current</a></li><li><a href="#method.idle_process_cx_ptr" title="idle_process_cx_ptr">idle_process_cx_ptr</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.process_current" title="process_current">process_current</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Processor" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-Processor" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-Processor" title="Freeze">Freeze</a></li><li><a href="#impl-Send-for-Processor" title="Send">Send</a></li><li><a href="#impl-Sync-for-Processor" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Processor" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In os::<wbr>process::<wbr>processor</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">os</a>::<wbr><a href="../index.html">process</a>::<wbr><a href="index.html">processor</a></div><h1>Struct <span class="struct">Processor</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/os/process/processor.rs.html#153-172">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Processor {
    current: Option&lt;Arc&lt;<a class="struct" href="../process/struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;,
    idle_process_cx: <a class="struct" href="../context/struct.ProcessContext.html" title="struct os::process::context::ProcessContext">ProcessContext</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>处理器状态管理器</p>
<p>管理单个 CPU 核心的执行状态，包括当前正在执行的进程和空闲进程上下文。
作为调度器的核心数据结构，协调进程之间的 CPU 资源分配。</p>
<h3 id="设计原理"><a class="doc-anchor" href="#设计原理">§</a>设计原理</h3><h4 id="双上下文模型"><a class="doc-anchor" href="#双上下文模型">§</a>双上下文模型</h4>
<p>处理器维护两种执行上下文：</p>
<ul>
<li><strong>进程上下文</strong>: 用户进程的执行状态（寄存器、栈指针等）</li>
<li><strong>空闲上下文</strong>: 调度器的执行状态，用于进程切换时的中转</li>
</ul>
<h4 id="所有权管理"><a class="doc-anchor" href="#所有权管理">§</a>所有权管理</h4>
<p>通过 <code>Option&lt;Arc&lt;ProcessControlBlock&gt;&gt;</code> 管理当前进程：</p>
<ul>
<li><code>Some(process)</code>: CPU 正在执行该进程</li>
<li><code>None</code>: CPU 处于空闲状态，等待新进程调度</li>
</ul>
<h3 id="状态转换"><a class="doc-anchor" href="#状态转换">§</a>状态转换</h3><div class="example-wrap"><pre class="language-text"><code>处理器状态转换:

   Idle State            Running State
┌─────────────┐         ┌─────────────┐
│   Idle      │ ──────► │   Running   │
│ current=None│Schedule │current=Some │
└─────────────┘         └──────┬──────┘
      ▲                        │
      │ Process Complete/Switch│
      └────────────────────────┘</code></pre></div><h3 id="内存布局"><a class="doc-anchor" href="#内存布局">§</a>内存布局</h3><div class="example-wrap"><pre class="language-text"><code>Processor 内存结构:
┌─────────────────────────────────────┐
│           Processor                 │
├─────────────────────────────────────┤
│ current: Option&lt;Arc&lt;TCB&gt;&gt;           │
│  └─ Some: Points to Current TCB     │
│  └─ None: Processor Idle            │
├─────────────────────────────────────┤
│ idle_process_cx: ProcessContext     │
│  └─ ra: Return Address              │
│  └─ sp: Stack Pointer               │
│  └─ s0-s11: Saved Registers         │
└─────────────────────────────────────┘</code></pre></div><h3 id="并发安全"><a class="doc-anchor" href="#并发安全">§</a>并发安全</h3>
<p><code>Processor</code> 本身不提供线程安全保证，必须通过 <code>UPSafeCell</code> 包装：</p>
<ul>
<li>单处理器系统中通过禁用中断保证原子性</li>
<li>多处理器系统需要额外的同步机制</li>
</ul>
<h3 id="性能特征"><a class="doc-anchor" href="#性能特征">§</a>性能特征</h3>
<ul>
<li><strong>内存占用</strong>: 约 264 bytes（ProcessContext ≈ 264 bytes + Arc 指针）</li>
<li><strong>切换开销</strong>: O(1) 常数时间的上下文切换</li>
<li><strong>缓存友好</strong>: 紧凑的内存布局提供良好的缓存局部性</li>
</ul>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.current" class="structfield section-header"><a href="#structfield.current" class="anchor field">§</a><code>current: Option&lt;Arc&lt;<a class="struct" href="../process/struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;</code></span><div class="docblock"><p>当前正在执行的进程</p>
<ul>
<li><code>Some(process)</code>: 指向正在 CPU 上执行的进程控制块</li>
<li><code>None</code>: CPU 处于空闲状态，调度器正在寻找下一个可运行进程</li>
</ul>
<p>使用 <code>Arc</code> 允许进程控制块在调度器和其他组件之间共享所有权。</p>
</div><span id="structfield.idle_process_cx" class="structfield section-header"><a href="#structfield.idle_process_cx" class="anchor field">§</a><code>idle_process_cx: <a class="struct" href="../context/struct.ProcessContext.html" title="struct os::process::context::ProcessContext">ProcessContext</a></code></span><div class="docblock"><p>空闲进程上下文</p>
<p>当没有用户进程运行时，CPU 执行调度器循环的上下文。
包含调度器的寄存器状态，用于在进程切换时保存/恢复调度器状态。</p>
<h4 id="作用"><a class="doc-anchor" href="#作用">§</a>作用</h4>
<ul>
<li><strong>进程切换中转</strong>: 从进程A切换到进程B时的中间状态</li>
<li><strong>调度器状态</strong>: 保存调度器循环的执行状态</li>
<li><strong>空闲处理</strong>: CPU 空闲时的默认执行上下文</li>
</ul>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Processor" class="impl"><a class="src rightside" href="../../../src/os/process/processor.rs.html#174-342">Source</a><a href="#impl-Processor" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Processor.html" title="struct os::process::processor::Processor">Processor</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/os/process/processor.rs.html#200-205">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>创建新的处理器实例</p>
<p>初始化一个空闲状态的处理器，准备接受进程调度。
处理器创建时没有当前进程，空闲上下文被清零。</p>
<h6 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h6>
<p>新创建的处理器实例，处于空闲状态</p>
<h6 id="初始状态"><a class="doc-anchor" href="#初始状态">§</a>初始状态</h6>
<ul>
<li><code>current</code>: <code>None</code> - 没有正在执行的进程</li>
<li><code>idle_process_cx</code>: 零初始化的进程上下文</li>
</ul>
<h6 id="使用场景"><a class="doc-anchor" href="#使用场景">§</a>使用场景</h6>
<ul>
<li>系统初始化时创建全局处理器</li>
<li>多处理器系统中创建额外的处理器核心</li>
</ul>
<h6 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>processor = Processor::new();
<span class="macro">assert!</span>(processor.current().is_none()); <span class="comment">// 初始状态为空闲</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.current" class="method"><a class="src rightside" href="../../../src/os/process/processor.rs.html#247-249">Source</a><h4 class="code-header">pub fn <a href="#method.current" class="fn">current</a>(&amp;self) -&gt; Option&lt;Arc&lt;<a class="struct" href="../process/struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>获取当前正在执行的进程（克隆引用）</p>
<p>返回当前进程控制块的克隆引用，保持原始引用不变。
适用于需要访问当前进程信息但不需要取走所有权的场景。</p>
<h6 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h6>
<ul>
<li><code>Some(Arc&lt;ProcessControlBlock&gt;)</code> - 当前进程的克隆引用</li>
<li><code>None</code> - 处理器当前处于空闲状态</li>
</ul>
<h6 id="引用计数"><a class="doc-anchor" href="#引用计数">§</a>引用计数</h6>
<p>此函数会增加进程控制块的引用计数：</p>
<div class="example-wrap"><pre class="language-text"><code>调用前: Arc::strong_count = n
调用后: Arc::strong_count = n + 1</code></pre></div><h6 id="使用场景-1"><a class="doc-anchor" href="#使用场景-1">§</a>使用场景</h6>
<ul>
<li><strong>信息查询</strong>: 获取当前进程的 PID、状态等信息</li>
<li><strong>权限检查</strong>: 验证当前进程的访问权限</li>
<li><strong>上下文共享</strong>: 在多个组件间共享进程引用</li>
</ul>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if let </span><span class="prelude-val">Some</span>(process) = processor.current() {
    <span class="macro">println!</span>(<span class="string">"Current PID: {}"</span>, process.getpid());
    <span class="comment">// 进程引用在作用域结束时自动释放
</span>} <span class="kw">else </span>{
    <span class="macro">println!</span>(<span class="string">"No process currently running"</span>);
}</code></pre></div>
<h6 id="性能考虑"><a class="doc-anchor" href="#性能考虑">§</a>性能考虑</h6>
<ul>
<li>引用计数操作开销很小（原子操作）</li>
<li>适合频繁的只读访问场景</li>
<li>避免不必要的所有权转移</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.process_current" class="method"><a class="src rightside" href="../../../src/os/process/processor.rs.html#299-301">Source</a><h4 class="code-header">pub fn <a href="#method.process_current" class="fn">process_current</a>(&amp;mut self) -&gt; Option&lt;Arc&lt;<a class="struct" href="../process/struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>取出当前正在执行的进程（转移所有权）</p>
<p>移除并返回当前进程控制块，将处理器设置为空闲状态。
这是一个所有权转移操作，调用后处理器不再持有进程引用。</p>
<h6 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h6>
<ul>
<li><code>Some(Arc&lt;ProcessControlBlock&gt;)</code> - 被取出的进程控制块</li>
<li><code>None</code> - 处理器已经处于空闲状态</li>
</ul>
<h6 id="状态变化"><a class="doc-anchor" href="#状态变化">§</a>状态变化</h6><div class="example-wrap"><pre class="language-text"><code>调用前: current = Some(process), 处理器运行状态
调用后: current = None,       处理器空闲状态</code></pre></div><h6 id="使用场景-2"><a class="doc-anchor" href="#使用场景-2">§</a>使用场景</h6>
<ul>
<li><strong>进程切换</strong>: 在调度新进程前取出当前进程</li>
<li><strong>进程完成</strong>: 进程退出时清理处理器状态</li>
<li><strong>进程挂起</strong>: 将进程转移到等待队列</li>
</ul>
<h6 id="调度流程中的作用"><a class="doc-anchor" href="#调度流程中的作用">§</a>调度流程中的作用</h6><div class="example-wrap"><pre class="language-text"><code>1. take_current_process() ──► 取出当前进程
2. 进程状态处理 ────────► 加入就绪队列或退出
3. fetch_process() ───────► 获取新进程
4. 设置新的 current ───► 开始执行新进程</code></pre></div><h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 在进程调度中使用
</span><span class="kw">if let </span><span class="prelude-val">Some</span>(old_process) = processor.process_current() {
    <span class="comment">// 处理旧进程（加入就绪队列、退出等）
    </span>handle_process_switch(old_process);
}
<span class="comment">// 现在处理器处于空闲状态，可以调度新进程</span></code></pre></div>
<h6 id="注意事项"><a class="doc-anchor" href="#注意事项">§</a>注意事项</h6>
<ul>
<li>调用后处理器立即进入空闲状态</li>
<li>必须确保在合适的时机调用，避免进程丢失</li>
<li>通常与进程调度算法配合使用</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.idle_process_cx_ptr" class="method"><a class="src rightside" href="../../../src/os/process/processor.rs.html#339-341">Source</a><h4 class="code-header">fn <a href="#method.idle_process_cx_ptr" class="fn">idle_process_cx_ptr</a>(&amp;mut self) -&gt; *mut <a class="struct" href="../context/struct.ProcessContext.html" title="struct os::process::context::ProcessContext">ProcessContext</a></h4></section></summary><div class="docblock"><p>获取空闲进程上下文的可变指针</p>
<p>返回指向空闲进程上下文的原始指针，用于底层的上下文切换操作。
这是一个私有方法，只在内部上下文切换时使用。</p>
<h6 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h6>
<p><code>*mut ProcessContext</code> - 指向空闲上下文的可变原始指针</p>
<h6 id="安全性考虑"><a class="doc-anchor" href="#安全性考虑">§</a>安全性考虑</h6>
<p>此方法返回原始指针，调用者必须确保：</p>
<ul>
<li>指针在使用期间保持有效</li>
<li>不会导致数据竞争或内存安全问题</li>
<li>只在适当的同步保护下使用</li>
</ul>
<h6 id="使用场景-3"><a class="doc-anchor" href="#使用场景-3">§</a>使用场景</h6>
<ul>
<li><strong>上下文切换</strong>: 在 <code>__switch</code> 汇编函数中使用</li>
<li><strong>调度器循环</strong>: 保存/恢复调度器状态</li>
<li><strong>进程切换中转</strong>: 作为进程间切换的中介</li>
</ul>
<h6 id="上下文切换流程"><a class="doc-anchor" href="#上下文切换流程">§</a>上下文切换流程</h6><div class="example-wrap"><pre class="language-text"><code>1. 保存当前进程上下文到进程控制块
2. 恢复空闲上下文 ────────────► 返回调度器
3. 调度器选择新进程
4. 保存空闲上下文 ────────────► 为下次切换准备
5. 恢复新进程上下文 ─────────► 执行新进程</code></pre></div><h6 id="内存布局-1"><a class="doc-anchor" href="#内存布局-1">§</a>内存布局</h6>
<p>返回的指针指向 <code>idle_process_cx</code> 字段的内存地址，
包含完整的 RISC-V 寄存器上下文信息。</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Processor" class="impl"><a href="#impl-Freeze-for-Processor" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.Processor.html" title="struct os::process::processor::Processor">Processor</a></h3></section><section id="impl-RefUnwindSafe-for-Processor" class="impl"><a href="#impl-RefUnwindSafe-for-Processor" class="anchor">§</a><h3 class="code-header">impl !RefUnwindSafe for <a class="struct" href="struct.Processor.html" title="struct os::process::processor::Processor">Processor</a></h3></section><section id="impl-Send-for-Processor" class="impl"><a href="#impl-Send-for-Processor" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.Processor.html" title="struct os::process::processor::Processor">Processor</a></h3></section><section id="impl-Sync-for-Processor" class="impl"><a href="#impl-Sync-for-Processor" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.Processor.html" title="struct os::process::processor::Processor">Processor</a></h3></section><section id="impl-Unpin-for-Processor" class="impl"><a href="#impl-Unpin-for-Processor" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.Processor.html" title="struct os::process::processor::Processor">Processor</a></h3></section><section id="impl-UnwindSafe-for-Processor" class="impl"><a href="#impl-UnwindSafe-for-Processor" class="anchor">§</a><h3 class="code-header">impl !UnwindSafe for <a class="struct" href="struct.Processor.html" title="struct os::process::processor::Processor">Processor</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>