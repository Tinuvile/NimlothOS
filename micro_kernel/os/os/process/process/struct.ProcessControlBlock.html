<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="进程控制块 (Process Control Block)"><title>ProcessControlBlock in os::process::process - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="os" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (ce36a966c 2025-02-17)" data-channel="nightly" data-search-js="search-f7327375.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5332ae0c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../os/index.html">os</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Process<wbr>Control<wbr>Block</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#结构组成" title="结构组成">结构组成</a><ul><li><a href="#不变部分直接字段" title="不变部分（直接字段）">不变部分（直接字段）</a></li><li><a href="#可变部分受保护字段" title="可变部分（受保护字段）">可变部分（受保护字段）</a></li></ul></li><li><a href="#设计优势" title="设计优势">设计优势</a></li><li><a href="#生命周期" title="生命周期">生命周期</a></li><li><a href="#使用模式" title="使用模式">使用模式</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.inner" title="inner">inner</a></li><li><a href="#structfield.kernel_stack" title="kernel_stack">kernel_stack</a></li><li><a href="#structfield.pid" title="pid">pid</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.exec" title="exec">exec</a></li><li><a href="#method.fork" title="fork">fork</a></li><li><a href="#method.getpid" title="getpid">getpid</a></li><li><a href="#method.inner_exclusive_access" title="inner_exclusive_access">inner_exclusive_access</a></li><li><a href="#method.new" title="new">new</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-ProcessControlBlock" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-ProcessControlBlock" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-ProcessControlBlock" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Send-for-ProcessControlBlock" title="Send">Send</a></li><li><a href="#impl-Sync-for-ProcessControlBlock" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-ProcessControlBlock" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In os::<wbr>process::<wbr>process</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">os</a>::<wbr><a href="../index.html">process</a>::<wbr><a href="index.html">process</a></div><h1>Struct <span class="struct">ProcessControlBlock</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/os/process/process.rs.html#233-255">Source</a> </span></div><pre class="rust item-decl"><code>pub struct ProcessControlBlock {
    pub pid: <a class="struct" href="../pid/struct.PidHandle.html" title="struct os::process::pid::PidHandle">PidHandle</a>,
    pub kernel_stack: <a class="struct" href="../pid/struct.KernelStack.html" title="struct os::process::pid::KernelStack">KernelStack</a>,
    inner: <a class="struct" href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell">UPSafeCell</a>&lt;<a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a>&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>进程控制块 (Process Control Block)</p>
<p>操作系统中每个进程的核心数据结构，包含进程运行所需的全部信息。
TCB 采用内外分离设计，将不变和可变部分分开管理，提高并发访问效率。</p>
<h3 id="结构组成"><a class="doc-anchor" href="#结构组成">§</a>结构组成</h3><h4 id="不变部分直接字段"><a class="doc-anchor" href="#不变部分直接字段">§</a>不变部分（直接字段）</h4>
<ul>
<li><code>pid</code>: 进程标识符句柄，进程生命周期内唯一且不变</li>
<li><code>kernel_stack</code>: 内核栈，用于系统调用和中断处理</li>
</ul>
<h4 id="可变部分受保护字段"><a class="doc-anchor" href="#可变部分受保护字段">§</a>可变部分（受保护字段）</h4>
<ul>
<li><code>inner</code>: 包含所有可变状态，使用 <a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a> 进行互斥保护</li>
</ul>
<h3 id="设计优势"><a class="doc-anchor" href="#设计优势">§</a>设计优势</h3>
<p><strong>性能优化</strong>：</p>
<ul>
<li>不变字段可以直接访问，避免锁开销</li>
<li>可变字段集中保护，减少锁的粒度和争用</li>
</ul>
<p><strong>并发安全</strong>：</p>
<ul>
<li><a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a> 提供单处理器环境下的安全可变访问</li>
<li>通过 [<code>Arc</code>] 支持多处理器环境下的引用计数管理</li>
<li>通过 [<code>Weak</code>] 避免循环引用，防止内存泄漏</li>
</ul>
<p><strong>资源管理</strong>：</p>
<ul>
<li>PID 和内核栈通过 RAII 自动管理生命周期</li>
<li>内存集合在进程退出时自动清理</li>
</ul>
<h3 id="生命周期"><a class="doc-anchor" href="#生命周期">§</a>生命周期</h3><div class="example-wrap"><pre class="language-text"><code>创建阶段:
┌────────────-─┐    ┌─-────────────--┐    ┌────────────┐
│ Allocate PID │───►│ Create K-Stack │───►│ Parse ELF  │
└──────────-───┘    └-────────────-─-┘    └────────────┘
                                                │
                                                ▼
┌────────────┐    ┌─-────────-────┐      ┌──────────--───┐
│ Init State │◄───│ Setup AddrSpc │  ◄─  │ Setup TrapCtx │
└-───────────┘    └-─────────────-┘      └────────────--─┘

运行阶段：
Ready ──Schedule──► Running ──Timeslice/Yield──► Ready
                      │
                      │ exit()
                      ▼
                   Zombie ──wait()──► Destroy

销毁阶段:
┌─────────────┐    ┌───────────-──┐    ┌──────────┐
│ Free Memory │───►│ Free K-Stack │───►│ Free PID │
└─────────────┘    └─────────────-┘    └──────────┘</code></pre></div><h3 id="使用模式"><a class="doc-anchor" href="#使用模式">§</a>使用模式</h3>
<p>TCB 通常包装在 [<code>Arc</code>] 中使用，支持多所有者场景：</p>
<ul>
<li>进程管理器持有引用进行调度</li>
<li>父进程持有子进程引用进行管理</li>
<li>处理器持有当前运行进程的引用</li>
</ul>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloc::sync::Arc;

<span class="comment">// 创建新进程
</span><span class="kw">let </span>elf_data = <span class="macro">include_bytes!</span>(<span class="string">"user_program.elf"</span>);
<span class="kw">let </span>process = Arc::new(ProcessControlBlock::new(elf_data));

<span class="comment">// 访问不变字段（无需锁）
</span><span class="macro">println!</span>(<span class="string">"Process PID: {}"</span>, process.getpid());

<span class="comment">// 访问可变字段（需要获取锁）
</span>{
    <span class="kw">let </span>inner = process.inner_exclusive_access();
    <span class="macro">println!</span>(<span class="string">"Process status: {:?}"</span>, inner.process_status);
} <span class="comment">// 锁在此处自动释放

// Fork 创建子进程
</span><span class="kw">let </span>child_process = process.fork();</code></pre></div>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.pid" class="structfield section-header"><a href="#structfield.pid" class="anchor field">§</a><code>pid: <a class="struct" href="../pid/struct.PidHandle.html" title="struct os::process::pid::PidHandle">PidHandle</a></code></span><div class="docblock"><p>进程标识符句柄</p>
<p>包含系统唯一的进程 ID，通过 RAII 机制自动管理 PID 的分配和回收。
在进程的整个生命周期中保持不变，可以安全地并发访问。</p>
</div><span id="structfield.kernel_stack" class="structfield section-header"><a href="#structfield.kernel_stack" class="anchor field">§</a><code>kernel_stack: <a class="struct" href="../pid/struct.KernelStack.html" title="struct os::process::pid::KernelStack">KernelStack</a></code></span><div class="docblock"><p>内核栈</p>
<p>每个进程在内核空间中的独立栈空间，用于：</p>
<ul>
<li>系统调用处理时的临时数据存储</li>
<li>中断和异常处理时的上下文保存</li>
<li>进程切换时的寄存器保存</li>
</ul>
<p>通过 RAII 机制自动管理内核栈的分配、映射和回收。</p>
</div><span id="structfield.inner" class="structfield section-header"><a href="#structfield.inner" class="anchor field">§</a><code>inner: <a class="struct" href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell">UPSafeCell</a>&lt;<a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a>&gt;</code></span><div class="docblock"><p>内部可变状态</p>
<p>包含所有需要在运行时修改的进程状态信息，使用 <a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a>
提供线程安全的可变访问。包括进程状态、内存集合、上下文等。</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ProcessControlBlock" class="impl"><a class="src rightside" href="../../../src/os/process/process.rs.html#732-1454">Source</a><a href="#impl-ProcessControlBlock" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#844-890">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(elf_data: &amp;[u8]) -&gt; Self</h4></section></summary><div class="docblock"><p>从 ELF 文件创建新的进程控制块</p>
<p>解析给定的 ELF 可执行文件，创建完整的进程控制块。
包括分配 PID、创建内核栈、建立地址空间和初始化陷阱上下文。</p>
<h6 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h6>
<ul>
<li><code>elf_data</code> - ELF 文件的二进制数据切片，必须是有效的 ELF 格式</li>
</ul>
<h6 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h6>
<p>返回初始化完成的进程控制块，状态为 <a href="enum.ProcessStatus.html#variant.Ready" title="variant os::process::process::ProcessStatus::Ready"><code>ProcessStatus::Ready</code></a></p>
<h6 id="初始化过程"><a class="doc-anchor" href="#初始化过程">§</a>初始化过程</h6><div class="example-wrap"><pre class="language-text"><code>1. 解析 ELF 文件
   │
   │ - 提取程序段（.text, .data, .bss 等）
   │ - 获取入口点地址和用户栈指针
   ▼
2. 建立地址空间
   │
   │ - 创建用户态地址空间
   │ - 映射程序段、用户栈、Trampoline 等
   ▼
3. 分配系统资源
   │
   │ - 分配 PID
   │ - 创建内核栈
   ▼
4. 初始化上下文
   │
   │ - 设置进程上下文（指向 trap_return）
   │ - 设置陷阱上下文（用户态寄存器初始值）
   ▼
5. 进程创建完成</code></pre></div><h6 id="内存布局"><a class="doc-anchor" href="#内存布局">§</a>内存布局</h6>
<p>创建后的进程具有以下内存布局：</p>
<div class="example-wrap"><pre class="language-text"><code>用户地址空间:
高地址 TRAMPOLINE
┌────────────────────┐
│    Trampoline      │ ← 用户态/内核态切换代码
├────────────────────┤
│   Trap Context     │ ← 用户态寄存器状态
├────────────────────┤
│    User Stack      │ ← 用户态栈空间
├────────────────────┤
│    Guard Page      │ ← 防止栈溢出
├────────────────────┤
│  Program Sections  │ ← .text/.data/.bss
└────────────────────┘
低地址 0x10000

内核地址空间:
┌────────────────────┐
│   Kernel Stack     │ ← 系统调用处理时使用
└────────────────────┘</code></pre></div><h6 id="初始状态"><a class="doc-anchor" href="#初始状态">§</a>初始状态</h6>
<p>新创建的进程具有以下初始状态：</p>
<ul>
<li><strong>进程状态</strong>: <a href="enum.ProcessStatus.html#variant.Ready" title="variant os::process::process::ProcessStatus::Ready"><code>ProcessStatus::Ready</code></a> - 准备执行</li>
<li><strong>父进程</strong>: <code>None</code> - 无父进程关系</li>
<li><strong>子进程</strong>: 空列表 - 暂无子进程</li>
<li><strong>退出码</strong>: 0 - 默认退出码</li>
</ul>
<h6 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h6>
<p>在以下情况下会触发 panic：</p>
<ul>
<li>ELF 文件格式错误或无效</li>
<li>PID 分配失败（系统 PID 资源耗尽）</li>
<li>内核栈分配失败（内存不足）</li>
<li>地址空间创建失败（虚拟内存系统错误）</li>
</ul>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloc::sync::Arc;

<span class="comment">// 从应用程序数据创建进程
</span><span class="kw">let </span>app_data = app_data(<span class="number">0</span>);
<span class="kw">let </span>process = Arc::new(ProcessControlBlock::new(app_data));

<span class="comment">// 检查初始状态
</span>{
    <span class="kw">let </span>inner = process.inner_exclusive_access();
    <span class="macro">assert_eq!</span>(inner.process_status, ProcessStatus::Ready);
    <span class="macro">assert_eq!</span>(inner.exit_code, <span class="number">0</span>);
    <span class="macro">assert!</span>(inner.parent.is_none());
    <span class="macro">assert!</span>(inner.children.is_empty());
}

<span class="macro">println!</span>(<span class="string">"Created process with PID: {}"</span>, process.getpid());</code></pre></div>
<h6 id="相关方法"><a class="doc-anchor" href="#相关方法">§</a>相关方法</h6>
<ul>
<li>[<code>fork()</code>] - 从现有进程创建子进程</li>
<li>[<code>exec()</code>] - 替换当前进程的可执行文件</li>
</ul>
<h6 id="行为"><a class="doc-anchor" href="#行为">§</a>行为</h6>
<ul>
<li>解析 ELF → 构建 <code>MemorySet</code>（含 trampoline、trap context、user stack）</li>
<li>分配 <code>PidHandle</code> 与 <code>KernelStack</code>，设置进程上下文返回到 <code>trap_return</code></li>
<li>初始化标准文件描述符（0/1/2）与信号相关字段</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.inner_exclusive_access" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#965-967">Source</a><h4 class="code-header">pub fn <a href="#method.inner_exclusive_access" class="fn">inner_exclusive_access</a>(&amp;self) -&gt; RefMut&lt;'_, <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a>&gt;</h4></section></summary><div class="docblock"><p>获取内部状态的排他访问权</p>
<p>返回 <a href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner"><code>ProcessControlBlockInner</code></a> 的排他可变引用，用于安全地读取和修改
进程的可变状态。在同一时刻只能有一个访问者获得访问权。</p>
<h6 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h6>
<p>返回 [<code>RefMut&lt;ProcessControlBlockInner&gt;</code>]，提供对内部状态的排他访问</p>
<h6 id="并发安全"><a class="doc-anchor" href="#并发安全">§</a>并发安全</h6>
<p>通过 <a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a> 的互斥机制保证：</p>
<ul>
<li><strong>排他性</strong>: 同一时刻只能有一个访问者</li>
<li><strong>未欣正风险</strong>: 编译时检查并发访问合法性</li>
<li><strong>自动释放</strong>: 引用超出作用域时自动释放锁</li>
</ul>
<h6 id="使用模式-1"><a class="doc-anchor" href="#使用模式-1">§</a>使用模式</h6>
<p>应该尽可能缩短锁的持有时间，避免阵塞其他线程：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 推荐的使用方式：短时间持有锁
</span>{
    <span class="kw">let </span><span class="kw-2">mut </span>inner = process.inner_exclusive_access();
    inner.process_status = ProcessStatus::Running;
    <span class="comment">// 其他对 inner 的操作...
</span>} <span class="comment">// 锁在此处自动释放

// 不推荐：长时间持有锁
</span><span class="kw">let </span><span class="kw-2">mut </span>inner = process.inner_exclusive_access();
<span class="comment">// 长时间的计算或 I/O 操作...
</span>heavy_computation();
inner.process_status = ProcessStatus::Ready;</code></pre></div>
<h6 id="常用操作"><a class="doc-anchor" href="#常用操作">§</a>常用操作</h6>
<p>通过排他访问可以执行以下操作：</p>
<ul>
<li><strong>状态管理</strong>: 修改进程状态和退出码</li>
<li><strong>上下文访问</strong>: 获取陷阱上下文和进程上下文</li>
<li><strong>内存管理</strong>: 访问和修改地址空间</li>
<li><strong>进程关系</strong>: 管理父子进程关系</li>
</ul>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 修改进程状态
</span>{
    <span class="kw">let </span><span class="kw-2">mut </span>inner = process.inner_exclusive_access();
    inner.process_status = ProcessStatus::Running;
}

<span class="comment">// 访问陷阱上下文
</span>{
    <span class="kw">let </span>inner = process.inner_exclusive_access();
    <span class="kw">let </span>trap_cx = inner.trap_cx();
    <span class="kw">let </span>syscall_id = trap_cx.x[<span class="number">17</span>];
}

<span class="comment">// 检查进程状态
</span>{
    <span class="kw">let </span>inner = process.inner_exclusive_access();
    <span class="kw">if </span>inner.is_zombie() {
        <span class="macro">println!</span>(<span class="string">"Process exited with code: {}"</span>, inner.exit_code);
    }
}</code></pre></div>
<h6 id="性能考虑"><a class="doc-anchor" href="#性能考虑">§</a>性能考虑</h6>
<ul>
<li><strong>锁争用</strong>: 高频率访问可能导致性能下降</li>
<li><strong>死锁防范</strong>: 避免在持有锁时获取其他锁</li>
<li><strong>内存开销</strong>: <code>RefMut</code> 本身有较小的运行时开销</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.getpid" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#1042-1044">Source</a><h4 class="code-header">pub fn <a href="#method.getpid" class="fn">getpid</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>获取进程 ID</p>
<p>返回当前进程的进程标识符 (PID)。PID 在系统中全局唯一，
用于识别和区分不同的进程。</p>
<h6 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h6>
<p>返回 <code>usize</code> 类型的 PID 值，PID 从 0 开始分配</p>
<h6 id="特性"><a class="doc-anchor" href="#特性">§</a>特性</h6>
<ul>
<li><strong>唯一性</strong>: PID 在系统运行期间唯一标识一个进程</li>
<li><strong>不变性</strong>: PID 在进程生命周期内不变</li>
<li><strong>递增性</strong>: PID 按创建顺序递增分配（在回收重用前）</li>
<li><strong>无锁访问</strong>: 获取 PID 不需要获取任何锁</li>
</ul>
<h6 id="使用场景"><a class="doc-anchor" href="#使用场景">§</a>使用场景</h6>
<ul>
<li><strong>进程管理</strong>: 系统调用中识别调用进程</li>
<li><strong>调试输出</strong>: 日志和调试信息中显示进程 ID</li>
<li><strong>进程通信</strong>: 信号、管道等进程间通信机制</li>
<li><strong>资源管理</strong>: 进程资源统计和限制</li>
<li><strong>安全检查</strong>: 权限验证和访问控制</li>
</ul>
<h6 id="与-posix-兼容性"><a class="doc-anchor" href="#与-posix-兼容性">§</a>与 POSIX 兼容性</h6>
<p>返回的 PID 值遵循 POSIX 约定：</p>
<ul>
<li>PID 0 通常保留给系统调度器</li>
<li>PID 1 通常是 init 进程</li>
<li>正数 PID 表示正常用户进程</li>
</ul>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 获取当前进程的 PID
</span><span class="kw">let </span>current_pid = process.getpid();
<span class="macro">println!</span>(<span class="string">"Current process PID: {}"</span>, current_pid);

<span class="comment">// 在系统调用中使用
</span><span class="kw">match </span>syscall_id {
    SYS_GETPID =&gt; {
        <span class="kw">let </span>pid = current_process().unwrap().getpid();
        <span class="comment">// 返回 PID 给用户程序
        </span>pid <span class="kw">as </span>isize
    }
    <span class="kw">_ </span>=&gt; -<span class="number">1</span>,
}

<span class="comment">// 进程管理中的使用
</span><span class="kw">fn </span>kill_process(target_pid: usize) -&gt; bool {
    <span class="kw">for </span>process <span class="kw">in </span><span class="kw-2">&amp;</span>process_list {
        <span class="kw">if </span>process.getpid() == target_pid {
            <span class="comment">// 找到目标进程，执行终止操作
            </span><span class="kw">return </span>terminate_process(process);
        }
    }
    <span class="bool-val">false </span><span class="comment">// 未找到目标进程
</span>}

<span class="comment">// 调试输出中的使用
</span><span class="macro">println!</span>(<span class="string">"Process {} entering syscall {}"</span>, process.getpid(), syscall_id);</code></pre></div>
<h6 id="性能特性"><a class="doc-anchor" href="#性能特性">§</a>性能特性</h6>
<ul>
<li><strong>O(1) 时间复杂度</strong>: 直接字段访问，无计算开销</li>
<li><strong>无锁开销</strong>: 不需要获取任何互斥锁</li>
<li><strong>缓存友好</strong>: 频繁调用不会产生额外开销</li>
</ul>
<h6 id="相关函数"><a class="doc-anchor" href="#相关函数">§</a>相关函数</h6>
<ul>
<li><a href="../pid/fn.pid_alloc.html" title="fn os::process::pid::pid_alloc"><code>pid_alloc()</code></a> - 分配新的 PID</li>
<li><a href="../pid/struct.PidHandle.html" title="struct os::process::pid::PidHandle"><code>PidHandle</code></a> - PID 的 RAII 封装</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fork" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#1196-1243">Source</a><h4 class="code-header">pub fn <a href="#method.fork" class="fn">fork</a>(self: &amp;Arc&lt;Self&gt;) -&gt; Arc&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Fork 系统调用实现：创建子进程</p>
<p>复制当前进程创建一个新的子进程，子进程继承父进程的地址空间、文件描述符等资源。
这是 UNIX/Linux 系统中创建新进程的主要方式，遵循经典的 fork 语义。</p>
<h6 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h6>
<ul>
<li><code>self</code> - 父进程的 Arc 引用，用于建立父子关系</li>
</ul>
<h6 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h6>
<p>返回新创建的子进程的 [<code>Arc&lt;ProcessControlBlock&gt;</code>]</p>
<h6 id="fork-语义"><a class="doc-anchor" href="#fork-语义">§</a>Fork 语义</h6>
<p><strong>父子进程差异</strong>：</p>
<ul>
<li><strong>PID</strong>: 子进程分配新的 PID</li>
<li><strong>内核栈</strong>: 子进程分配独立的内核栈</li>
<li><strong>返回值</strong>: 在父进程中返回子进程 PID，在子进程中返回 0</li>
</ul>
<p><strong>共享与复制</strong>：</p>
<ul>
<li><strong>地址空间</strong>: 子进程获得父进程地址空间的完整副本</li>
<li><strong>寄存器状态</strong>: 子进程继承父进程当前的所有寄存器值</li>
<li><strong>文件描述符</strong>: 子进程继承父进程打开的文件描述符</li>
<li><strong>工作目录</strong>: 子进程继承父进程的工作目录</li>
</ul>
<h6 id="fork-过程详解"><a class="doc-anchor" href="#fork-过程详解">§</a>Fork 过程详解</h6><div class="example-wrap"><pre class="language-text"><code>1. 复制地址空间
   │
   │ - 创建新的内存集合
   │ - 逐页复制父进程的所有内存内容
   │ - 建立独立的页表结构
   ▼
2. 分配系统资源
   │
   │ - 分配新的 PID
   │ - 创建独立的内核栈
   │ - 分配新的 TCB
   ▼
3. 建立父子关系
   │
   │ - 子进程记录父进程弱引用
   │ - 父进程添加子进程到 children 列表
   │ - 维护进程树结构
   ▼
4. 初始化子进程状态
   │
   │ - 设置进程状态为 Ready
   │ - 复制进程上下文
   │ - 调整内核栈指针
   ▼
5. 子进程创建完成</code></pre></div><h6 id="内存布局对比"><a class="doc-anchor" href="#内存布局对比">§</a>内存布局对比</h6><div class="example-wrap"><pre class="language-text"><code>Fork 前 (父进程):
┌─────────────────┐
│   Parent Process   │
│     (PID n)     │
├─────────────────┤
│  Address Space  │ ← 原始地址空间
│    Virtual      │
│     Memory      │
└─────────────────┘

Fork 后:
┌─────────────────┐    ┌─────────────────┐
│   Parent Process   │    │   Child Process    │
│     (PID n)     │    │    (PID n+1)    │
├─────────────────┤    ├─────────────────┤
│  Address Space  │    │  Address Space  │ ← 完整副本
│    (Original)   │    │     (Copy)      │
│     Memory      │    │     Memory      │
└─────────────────┘    └─────────────────┘
           │                      ▲
           └──────────────────────┘
                父子关系</code></pre></div><h6 id="系统调用返回值处理"><a class="doc-anchor" href="#系统调用返回值处理">§</a>系统调用返回值处理</h6>
<p>Fork 的一个重要特征是一次调用两次返回：</p>
<div class="example-wrap"><pre class="language-text"><code>调用时机：                父进程返回          子进程返回
┌──────────┐             ┌──────────┐        ┌──────────┐
│ fork()   │────────────►│child_pid │        │    0     │
│ SysCall  │             │          │        │          │
└──────────┘             └──────────┘        └──────────┘</code></pre></div>
<p>返回值设置在陷阱上下文中的 <code>x[10]</code> 寄存器（RISC-V ABI 返回值寄存器）。</p>
<h6 id="使用示例"><a class="doc-anchor" href="#使用示例">§</a>使用示例</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloc::sync::Arc;

<span class="comment">// 父进程执行 fork
</span><span class="kw">let </span>parent_process = Arc::new(ProcessControlBlock::new(parent_elf));
<span class="kw">let </span>child_process = parent_process.fork();

<span class="comment">// 检查父子关系
</span>{
    <span class="kw">let </span>child_inner = child_process.inner_exclusive_access();
    <span class="macro">assert!</span>(child_inner.parent.is_some());
}

{
    <span class="kw">let </span>parent_inner = parent_process.inner_exclusive_access();
    <span class="macro">assert_eq!</span>(parent_inner.children.len(), <span class="number">1</span>);
    <span class="macro">assert_eq!</span>(parent_inner.children[<span class="number">0</span>].getpid(), child_process.getpid());
}

<span class="macro">println!</span>(<span class="string">"Parent PID: {}, Child PID: {}"</span>,
         parent_process.getpid(), child_process.getpid());</code></pre></div>
<h6 id="错误处理"><a class="doc-anchor" href="#错误处理">§</a>错误处理</h6>
<p>Fork 可能在以下情况失败：</p>
<ul>
<li><strong>内存不足</strong>: 无法分配子进程的地址空间或内核栈</li>
<li><strong>PID 耗尽</strong>: 系统 PID 资源已用完</li>
<li><strong>系统限制</strong>: 达到进程数量或内存使用限制</li>
</ul>
<h6 id="性能考虑-1"><a class="doc-anchor" href="#性能考虑-1">§</a>性能考虑</h6>
<ul>
<li><strong>写时复制 (COW)</strong>: 某些系统实现 COW 优化，本实现为完整复制</li>
<li><strong>内存开销</strong>: 完整复制地址空间会消耗大量内存</li>
<li><strong>时间开销</strong>: 复制过程的时间与父进程地址空间大小成正比</li>
</ul>
<h6 id="risc-v-特定处理"><a class="doc-anchor" href="#risc-v-特定处理">§</a>RISC-V 特定处理</h6>
<ul>
<li><strong>内核栈指针</strong>: 更新子进程陷阱上下文中的内核栈指针</li>
<li><strong>寄存器继承</strong>: 子进程继承父进程的所有通用寄存器值</li>
<li><strong>特权模式</strong>: 子进程在用户模式下开始执行</li>
</ul>
<h6 id="相关系统调用"><a class="doc-anchor" href="#相关系统调用">§</a>相关系统调用</h6>
<ul>
<li>[<code>exec()</code>] - 替换进程映像，通常与 fork 配合使用</li>
<li>[<code>wait()</code>] - 父进程等待子进程退出</li>
<li>[<code>exit()</code>] - 进程正常退出</li>
</ul>
<h6 id="返回"><a class="doc-anchor" href="#返回">§</a>返回</h6>
<ul>
<li>父进程：返回新建子进程的 <code>Arc&lt;ProcessControlBlock&gt;</code>（随后入队由调度器运行）</li>
<li>子进程：调度运行后，从系统调用返回 <code>0</code></li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.exec" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#1410-1453">Source</a><h4 class="code-header">pub fn <a href="#method.exec" class="fn">exec</a>(&amp;self, elf_data: &amp;[u8], args: Vec&lt;String&gt;)</h4></section></summary><div class="docblock"><p>Exec 系统调用实现：替换进程映像</p>
<p>使用新的可执行文件替换当前进程的内存映像，保持相同的 PID 和内核栈，
但完全替换地址空间和执行上下文。这是 UNIX/Linux 系统加载新程序的标准方式。</p>
<h6 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments</h6>
<ul>
<li><code>elf_data</code> - 新程序的 ELF 文件二进制数据</li>
</ul>
<h6 id="exec-语义"><a class="doc-anchor" href="#exec-语义">§</a>Exec 语义</h6>
<p><strong>保持不变的部分</strong>：</p>
<ul>
<li><strong>PID</strong>: 进程标识符不变，仍然是同一个进程</li>
<li><strong>内核栈</strong>: 复用现有的内核栈，不重新分配</li>
<li><strong>父子关系</strong>: 进程在进程树中的位置不变</li>
</ul>
<p><strong>替换的部分</strong>：</p>
<ul>
<li><strong>地址空间</strong>: 完全替换为新程序的内存布局</li>
<li><strong>执行上下文</strong>: 重置为新程序的入口点和初始状态</li>
<li><strong>用户态寄存器</strong>: 重新初始化为新程序的启动状态</li>
</ul>
<h6 id="exec-过程详解"><a class="doc-anchor" href="#exec-过程详解">§</a>Exec 过程详解</h6><div class="example-wrap"><pre class="language-text"><code>1. 解析新的 ELF 文件
   │
   │ - 验证 ELF 文件格式
   │ - 提取程序段信息
   │ - 获取入口点地址
   ▼
2. 创建新的地址空间
   │
   │ - 销毁旧的内存映射
   │ - 建立新程序的内存布局
   │ - 加载程序段到内存
   ▼
3. 更新进程状态
   │
   │ - 更新内存集合
   │ - 更新陷阱上下文页号
   │ - 重新设置基础内存大小
   ▼
4. 初始化执行环境
   │
   │ - 设置程序计数器为入口点
   │ - 初始化用户栈指针
   │ - 清零通用寄存器
   ▼
5. 程序替换完成</code></pre></div><h6 id="内存布局变化"><a class="doc-anchor" href="#内存布局变化">§</a>内存布局变化</h6><div class="example-wrap"><pre class="language-text"><code>Exec 前 (旧程序):
┌─────────────────────────┐
│      Process (PID n)       │ ← PID 保持不变
├─────────────────────────┤
│     Old Program         │
│   Address Space:        │
│  ┌──────────────────┐   │
│  │ Old .text/.data  │   │ ← 将被完全替换
│  │ Old User Stack   │   │
│  │ Old Heap         │   │
│  └──────────────────┘   │
└─────────────────────────┘

Exec 后 (新程序):
┌─────────────────────────┐
│      Process (PID n)       │ ← 同一个 PID
├─────────────────────────┤
│     New Program         │
│   Address Space:        │
│  ┌──────────────────┐   │
│  │ New .text/.data  │   │ ← 新程序的内存布局
│  │ New User Stack   │   │
│  │ New Heap         │   │
│  └──────────────────┘   │
└─────────────────────────┘</code></pre></div><h6 id="上下文重置"><a class="doc-anchor" href="#上下文重置">§</a>上下文重置</h6>
<p>Exec 会重置进程的执行上下文：</p>
<div class="example-wrap"><pre class="language-text"><code>重置项目                 新值
┌──────────────────┐    ┌─────────────────────┐
│Program Counter   │───►│ New Entry Point     │
├──────────────────┤    ├─────────────────────┤
│Stack Pointer     │───►│ New User Stack Top  │
├──────────────────┤    ├─────────────────────┤
│General Registers │───►│ Zero or Init Values │
├──────────────────┤    ├─────────────────────┤
│Page Table Ptr    │───►│ New Address Space   │
└──────────────────┘    └─────────────────────┘</code></pre></div><h6 id="典型使用场景"><a class="doc-anchor" href="#典型使用场景">§</a>典型使用场景</h6>
<p><strong>Shell 命令执行</strong>：</p>
<div class="example-wrap"><pre class="language-text"><code>1. Shell 进程执行 fork() 创建子进程
2. 子进程执行 exec() 加载目标程序
3. 父进程 (Shell) 执行 wait() 等待子进程完成</code></pre></div>
<p><strong>程序动态加载</strong>：</p>
<div class="example-wrap"><pre class="language-text"><code>1. 当前进程不再需要原程序代码
2. 直接执行 exec() 替换为新程序
3. 新程序从头开始执行</code></pre></div><h6 id="使用示例-1"><a class="doc-anchor" href="#使用示例-1">§</a>使用示例</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 替换当前进程为新程序
</span><span class="kw">let </span>new_program = app_data(<span class="string">"target_app"</span>);

<span class="comment">// 记录替换前的信息
</span><span class="kw">let </span>old_pid = process.getpid();
<span class="macro">println!</span>(<span class="string">"Executing new program in PID {}"</span>, old_pid);

<span class="comment">// 执行替换
</span>process.exec(new_program);

<span class="comment">// 验证 PID 未变但程序已替换
</span><span class="macro">assert_eq!</span>(process.getpid(), old_pid);

<span class="comment">// 检查新的执行状态
</span>{
    <span class="kw">let </span>inner = process.inner_exclusive_access();
    <span class="kw">let </span>trap_cx = inner.trap_cx();
    <span class="macro">println!</span>(<span class="string">"New entry point: 0x{:x}"</span>, trap_cx.sepc);
    <span class="macro">println!</span>(<span class="string">"New stack pointer: 0x{:x}"</span>, trap_cx.x[<span class="number">2</span>]);
}</code></pre></div>
<h6 id="安全考虑"><a class="doc-anchor" href="#安全考虑">§</a>安全考虑</h6>
<ul>
<li><strong>权限检查</strong>: 确保有权限执行目标文件</li>
<li><strong>格式验证</strong>: 验证 ELF 文件的完整性和合法性</li>
<li><strong>资源清理</strong>: 确保旧程序的所有资源得到正确释放</li>
<li><strong>状态一致性</strong>: 保证替换过程的原子性</li>
</ul>
<h6 id="错误处理-1"><a class="doc-anchor" href="#错误处理-1">§</a>错误处理</h6>
<p>Exec 可能在以下情况失败：</p>
<ul>
<li><strong>文件格式错误</strong>: ELF 文件格式无效或损坏</li>
<li><strong>内存不足</strong>: 无法为新程序分配足够的内存空间</li>
<li><strong>权限不足</strong>: 没有执行目标文件的权限</li>
<li><strong>系统资源限制</strong>: 超出系统资源限制</li>
</ul>
<h6 id="性能特性-1"><a class="doc-anchor" href="#性能特性-1">§</a>性能特性</h6>
<ul>
<li><strong>内存复用</strong>: 复用现有的 PID 和内核栈资源</li>
<li><strong>快速切换</strong>: 相比 fork + exec 模式，单独 exec 更高效</li>
<li><strong>内存释放</strong>: 自动释放旧程序占用的所有内存</li>
</ul>
<h6 id="与其他系统调用的关系"><a class="doc-anchor" href="#与其他系统调用的关系">§</a>与其他系统调用的关系</h6>
<ul>
<li><strong>fork() + exec()</strong>: 经典的进程创建和程序加载模式</li>
<li><strong>wait()</strong>: 父进程等待 exec 后的子进程完成</li>
<li><strong>exit()</strong>: 进程执行完成后的正常退出</li>
</ul>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-ProcessControlBlock" class="impl"><a href="#impl-Freeze-for-ProcessControlBlock" class="anchor">§</a><h3 class="code-header">impl !Freeze for <a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a></h3></section><section id="impl-RefUnwindSafe-for-ProcessControlBlock" class="impl"><a href="#impl-RefUnwindSafe-for-ProcessControlBlock" class="anchor">§</a><h3 class="code-header">impl !RefUnwindSafe for <a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a></h3></section><section id="impl-Send-for-ProcessControlBlock" class="impl"><a href="#impl-Send-for-ProcessControlBlock" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a></h3></section><section id="impl-Sync-for-ProcessControlBlock" class="impl"><a href="#impl-Sync-for-ProcessControlBlock" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a></h3></section><section id="impl-Unpin-for-ProcessControlBlock" class="impl"><a href="#impl-Unpin-for-ProcessControlBlock" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a></h3></section><section id="impl-UnwindSafe-for-ProcessControlBlock" class="impl"><a href="#impl-UnwindSafe-for-ProcessControlBlock" class="anchor">§</a><h3 class="code-header">impl !UnwindSafe for <a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>