<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="进程控制块内部可变状态"><title>ProcessControlBlockInner in os::process::process - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="os" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (ce36a966c 2025-02-17)" data-channel="nightly" data-search-js="search-f7327375.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5332ae0c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../os/index.html">os</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Process<wbr>Control<wbr>Block<wbr>Inner</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#字段说明" title="字段说明">字段说明</a><ul><li><a href="#运行时状态" title="运行时状态">运行时状态</a></li><li><a href="#内存管理" title="内存管理">内存管理</a></li><li><a href="#进程关系" title="进程关系">进程关系</a></li></ul></li><li><a href="#设计考虑" title="设计考虑">设计考虑</a></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.base_size" title="base_size">base_size</a></li><li><a href="#structfield.children" title="children">children</a></li><li><a href="#structfield.exit_code" title="exit_code">exit_code</a></li><li><a href="#structfield.fd_table" title="fd_table">fd_table</a></li><li><a href="#structfield.frozen" title="frozen">frozen</a></li><li><a href="#structfield.handling_sig" title="handling_sig">handling_sig</a></li><li><a href="#structfield.killed" title="killed">killed</a></li><li><a href="#structfield.memory_set" title="memory_set">memory_set</a></li><li><a href="#structfield.parent" title="parent">parent</a></li><li><a href="#structfield.priority" title="priority">priority</a></li><li><a href="#structfield.process_cx" title="process_cx">process_cx</a></li><li><a href="#structfield.process_status" title="process_status">process_status</a></li><li><a href="#structfield.signal_actions" title="signal_actions">signal_actions</a></li><li><a href="#structfield.signal_mask" title="signal_mask">signal_mask</a></li><li><a href="#structfield.signals" title="signals">signals</a></li><li><a href="#structfield.time_slice_limit" title="time_slice_limit">time_slice_limit</a></li><li><a href="#structfield.time_slice_used" title="time_slice_used">time_slice_used</a></li><li><a href="#structfield.trap_ctx_backup" title="trap_ctx_backup">trap_ctx_backup</a></li><li><a href="#structfield.trap_cx_ppn" title="trap_cx_ppn">trap_cx_ppn</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.alloc_fd" title="alloc_fd">alloc_fd</a></li><li><a href="#method.is_zombie" title="is_zombie">is_zombie</a></li><li><a href="#method.status" title="status">status</a></li><li><a href="#method.trap_cx" title="trap_cx">trap_cx</a></li><li><a href="#method.user_token" title="user_token">user_token</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-ProcessControlBlockInner" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-ProcessControlBlockInner" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-ProcessControlBlockInner" title="Freeze">Freeze</a></li><li><a href="#impl-Send-for-ProcessControlBlockInner" title="Send">Send</a></li><li><a href="#impl-Sync-for-ProcessControlBlockInner" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-ProcessControlBlockInner" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In os::<wbr>process::<wbr>process</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">os</a>::<wbr><a href="../index.html">process</a>::<wbr><a href="index.html">process</a></div><h1>Struct <span class="struct">ProcessControlBlockInner</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/os/process/process.rs.html#294-463">Source</a> </span></div><pre class="rust item-decl"><code>pub struct ProcessControlBlockInner {<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 19 fields</span></summary>
    pub process_status: <a class="enum" href="enum.ProcessStatus.html" title="enum os::process::process::ProcessStatus">ProcessStatus</a>,
    pub process_cx: <a class="struct" href="../context/struct.ProcessContext.html" title="struct os::process::context::ProcessContext">ProcessContext</a>,
    pub memory_set: <a class="struct" href="../../mm/memory_set/struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a>,
    pub trap_cx_ppn: <a class="struct" href="../../mm/address/struct.PhysPageNum.html" title="struct os::mm::address::PhysPageNum">PhysPageNum</a>,
    pub base_size: usize,
    pub parent: Option&lt;Weak&lt;<a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;,
    pub children: Vec&lt;Arc&lt;<a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;,
    pub exit_code: i32,
    pub fd_table: Vec&lt;Option&lt;Arc&lt;dyn <a class="trait" href="../../fs/trait.File.html" title="trait os::fs::File">File</a> + Send + Sync&gt;&gt;&gt;,
    pub signals: <a class="struct" href="../signal/struct.SignalFlags.html" title="struct os::process::signal::SignalFlags">SignalFlags</a>,
    pub signal_mask: <a class="struct" href="../signal/struct.SignalFlags.html" title="struct os::process::signal::SignalFlags">SignalFlags</a>,
    pub handling_sig: isize,
    pub signal_actions: <a class="struct" href="../signal/struct.SignalActions.html" title="struct os::process::signal::SignalActions">SignalActions</a>,
    pub killed: bool,
    pub frozen: bool,
    pub trap_ctx_backup: Option&lt;<a class="struct" href="../../trap/context/struct.TrapContext.html" title="struct os::trap::context::TrapContext">TrapContext</a>&gt;,
    pub priority: usize,
    pub time_slice_used: usize,
    pub time_slice_limit: usize,
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>进程控制块内部可变状态</p>
<p>包含进程的所有可变状态信息，需要在运行时进行修改的字段都集中在此结构中。
通过 <a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a> 进行互斥保护，确保并发访问的安全性。</p>
<h3 id="字段说明"><a class="doc-anchor" href="#字段说明">§</a>字段说明</h3><h4 id="运行时状态"><a class="doc-anchor" href="#运行时状态">§</a>运行时状态</h4>
<ul>
<li><code>process_status</code>: 进程当前状态（Ready/Running/Zombie）</li>
<li><code>process_cx</code>: 进程上下文，保存寄存器状态用于进程切换</li>
<li><code>exit_code</code>: 进程退出码，用于父进程获取子进程执行结果</li>
</ul>
<h4 id="内存管理"><a class="doc-anchor" href="#内存管理">§</a>内存管理</h4>
<ul>
<li><code>memory_set</code>: 进程的完整地址空间，包含所有内存映射区域</li>
<li><code>trap_cx_ppn</code>: 陷阱上下文的物理页号，用于用户态/内核态切换</li>
<li><code>base_size</code>: 进程初始堆栈大小，用于内存分配决策</li>
</ul>
<h4 id="进程关系"><a class="doc-anchor" href="#进程关系">§</a>进程关系</h4>
<ul>
<li><code>parent</code>: 父进程的弱引用，避免循环引用导致内存泄漏</li>
<li><code>children</code>: 子进程列表，维护进程树结构</li>
</ul>
<h3 id="设计考虑"><a class="doc-anchor" href="#设计考虑">§</a>设计考虑</h3>
<p><strong>并发安全</strong>：</p>
<ul>
<li>所有字段都受到外层 <a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a> 的保护</li>
<li>访问时需要获取独占锁，避免数据竞争</li>
<li>锁的持有时间应当尽可能短，避免性能影响</li>
</ul>
<p><strong>内存管理</strong>：</p>
<ul>
<li><a href="../../mm/memory_set/struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet"><code>MemorySet</code></a> 自动管理进程地址空间的生命周期</li>
<li>使用 [<code>Arc</code>] 和 [<code>Weak</code>] 管理进程间的引用关系</li>
<li>进程退出时自动清理相关资源</li>
</ul>
<p><strong>状态一致性</strong>：</p>
<ul>
<li>进程状态与上下文信息保持同步</li>
<li>父子关系的双向引用保持一致</li>
<li>内存映射与陷阱上下文匹配</li>
</ul>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.process_status" class="structfield section-header"><a href="#structfield.process_status" class="anchor field">§</a><code>process_status: <a class="enum" href="enum.ProcessStatus.html" title="enum os::process::process::ProcessStatus">ProcessStatus</a></code></span><div class="docblock"><p>进程当前状态</p>
<p>表示进程在操作系统中的当前状态，影响调度器的调度决策。
状态转换遵循严格的状态机规则。</p>
</div><span id="structfield.process_cx" class="structfield section-header"><a href="#structfield.process_cx" class="anchor field">§</a><code>process_cx: <a class="struct" href="../context/struct.ProcessContext.html" title="struct os::process::context::ProcessContext">ProcessContext</a></code></span><div class="docblock"><p>进程上下文</p>
<p>保存进程在进程切换时需要恢复的寄存器状态，包括：</p>
<ul>
<li>返回地址 (ra): 进程恢复时的执行地址</li>
<li>栈指针 (sp): 内核栈的栈顶地址</li>
<li>被调用者保存寄存器 (s0-s11): 函数调用约定要求保存的寄存器</li>
</ul>
</div><span id="structfield.memory_set" class="structfield section-header"><a href="#structfield.memory_set" class="anchor field">§</a><code>memory_set: <a class="struct" href="../../mm/memory_set/struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></code></span><div class="docblock"><p>进程地址空间</p>
<p>管理进程的完整虚拟地址空间，包括：</p>
<ul>
<li>代码段、数据段、堆段、栈段的映射</li>
<li>页表管理和地址转换</li>
<li>内存权限控制和保护</li>
</ul>
</div><span id="structfield.trap_cx_ppn" class="structfield section-header"><a href="#structfield.trap_cx_ppn" class="anchor field">§</a><code>trap_cx_ppn: <a class="struct" href="../../mm/address/struct.PhysPageNum.html" title="struct os::mm::address::PhysPageNum">PhysPageNum</a></code></span><div class="docblock"><p>陷阱上下文物理页号</p>
<p>指向保存陷阱上下文的物理页面，陷阱上下文包含：</p>
<ul>
<li>用户态所有寄存器的值</li>
<li>系统调用参数和返回值</li>
<li>异常处理相关信息</li>
</ul>
</div><span id="structfield.base_size" class="structfield section-header"><a href="#structfield.base_size" class="anchor field">§</a><code>base_size: usize</code></span><div class="docblock"><p>进程基础内存大小</p>
<p>记录进程初始化时的内存使用情况，用于：</p>
<ul>
<li>内存分配和回收的决策参考</li>
<li>进程资源使用统计</li>
<li>堆空间管理的基准值</li>
</ul>
</div><span id="structfield.parent" class="structfield section-header"><a href="#structfield.parent" class="anchor field">§</a><code>parent: Option&lt;Weak&lt;<a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;</code></span><div class="docblock"><p>父进程引用</p>
<p>指向父进程的弱引用，用于维护进程树结构。使用 [<code>Weak</code>] 避免
父子进程间的循环引用，防止内存泄漏。当父进程退出时，
子进程会被重新指向 init 进程。</p>
</div><span id="structfield.children" class="structfield section-header"><a href="#structfield.children" class="anchor field">§</a><code>children: Vec&lt;Arc&lt;<a class="struct" href="struct.ProcessControlBlock.html" title="struct os::process::process::ProcessControlBlock">ProcessControlBlock</a>&gt;&gt;</code></span><div class="docblock"><p>子进程列表</p>
<p>维护当前进程的所有子进程，用于：</p>
<ul>
<li>实现 wait 系统调用，等待子进程退出</li>
<li>进程退出时处理孤儿进程，重新指向 init 进程</li>
<li>信号传递和进程组管理</li>
</ul>
</div><span id="structfield.exit_code" class="structfield section-header"><a href="#structfield.exit_code" class="anchor field">§</a><code>exit_code: i32</code></span><div class="docblock"><p>进程退出码</p>
<p>记录进程的退出状态，供父进程通过 wait 系统调用获取。
标准约定：0 表示正常退出，非零表示异常退出。</p>
</div><span id="structfield.fd_table" class="structfield section-header"><a href="#structfield.fd_table" class="anchor field">§</a><code>fd_table: Vec&lt;Option&lt;Arc&lt;dyn <a class="trait" href="../../fs/trait.File.html" title="trait os::fs::File">File</a> + Send + Sync&gt;&gt;&gt;</code></span><div class="docblock"><p>文件描述符表</p>
<p>维护进程打开的所有文件描述符，每个元素对应一个文件描述符：</p>
<ul>
<li><code>Some(file)</code> - 文件描述符已打开，指向对应的文件对象</li>
<li><code>None</code> - 文件描述符未使用，可以被重新分配</li>
</ul>
<h4 id="标准文件描述符"><a class="doc-anchor" href="#标准文件描述符">§</a>标准文件描述符</h4>
<p>进程创建时自动分配以下标准文件描述符：</p>
<ul>
<li><code>fd_table[0]</code> - 标准输入 (stdin) - <a href="../../fs/stdio/struct.Stdin.html" title="struct os::fs::stdio::Stdin"><code>Stdin</code></a></li>
<li><code>fd_table[1]</code> - 标准输出 (stdout) - <a href="../../fs/stdio/struct.Stdout.html" title="struct os::fs::stdio::Stdout"><code>Stdout</code></a></li>
<li><code>fd_table[2]</code> - 标准错误 (stderr) - <a href="../../fs/stdio/struct.Stderr.html" title="struct os::fs::stdio::Stderr"><code>Stderr</code></a></li>
</ul>
<p>这些标准文件描述符在进程创建时自动初始化，用户程序无需手动打开。
它们提供了基本的输入输出功能，遵循POSIX标准。</p>
<h4 id="文件描述符分配"><a class="doc-anchor" href="#文件描述符分配">§</a>文件描述符分配</h4>
<ul>
<li>新文件描述符从索引 0 开始查找第一个 <code>None</code> 位置</li>
<li>如果所有位置都被占用，则扩展表大小</li>
<li>文件描述符关闭时设置为 <code>None</code>，可以被重用</li>
</ul>
<h4 id="并发安全"><a class="doc-anchor" href="#并发安全">§</a>并发安全</h4>
<p>文件描述符表通过外层的 <a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a> 保护，确保并发访问安全。
文件对象本身通过 [<code>Arc</code>] 实现引用计数，支持多进程共享。</p>
<h4 id="使用场景"><a class="doc-anchor" href="#使用场景">§</a>使用场景</h4>
<ul>
<li>系统调用中查找和验证文件描述符</li>
<li>进程 fork 时复制文件描述符表</li>
<li>进程退出时关闭所有打开的文件</li>
<li>文件描述符的分配和回收管理</li>
</ul>
<h4 id="标准文件描述符的语义"><a class="doc-anchor" href="#标准文件描述符的语义">§</a>标准文件描述符的语义</h4><h5 id="标准输入-stdin-fd0"><a class="doc-anchor" href="#标准输入-stdin-fd0">§</a>标准输入 (stdin, fd=0)</h5>
<ul>
<li><strong>用途</strong>: 程序的标准输入源</li>
<li><strong>实现</strong>: <a href="../../fs/stdio/struct.Stdin.html" title="struct os::fs::stdio::Stdin"><code>Stdin</code></a> 结构体</li>
<li><strong>特性</strong>: 只读，阻塞式读取，支持单字符输入</li>
<li><strong>行为</strong>: 当没有输入时会让出CPU，等待用户输入</li>
</ul>
<h5 id="标准输出-stdout-fd1"><a class="doc-anchor" href="#标准输出-stdout-fd1">§</a>标准输出 (stdout, fd=1)</h5>
<ul>
<li><strong>用途</strong>: 程序的正常输出目标</li>
<li><strong>实现</strong>: <a href="../../fs/stdio/struct.Stdout.html" title="struct os::fs::stdio::Stdout"><code>Stdout</code></a> 结构体</li>
<li><strong>特性</strong>: 只写，实时输出，支持UTF-8编码</li>
<li><strong>行为</strong>: 立即将输出显示到控制台</li>
</ul>
<h5 id="标准错误-stderr-fd2"><a class="doc-anchor" href="#标准错误-stderr-fd2">§</a>标准错误 (stderr, fd=2)</h5>
<ul>
<li><strong>用途</strong>: 程序的错误信息和诊断输出</li>
<li><strong>实现</strong>: <a href="../../fs/stdio/struct.Stderr.html" title="struct os::fs::stdio::Stderr"><code>Stderr</code></a> 结构体</li>
<li><strong>特性</strong>: 只写，实时输出，支持UTF-8编码</li>
<li><strong>行为</strong>: 与标准输出类似，但语义上区分用途</li>
</ul>
<h4 id="文件描述符继承"><a class="doc-anchor" href="#文件描述符继承">§</a>文件描述符继承</h4>
<p>在fork操作中，子进程会继承父进程的所有文件描述符：</p>
<ul>
<li>标准文件描述符 (0, 1, 2) 被复制到子进程</li>
<li>用户打开的文件描述符也被复制</li>
<li>父子进程共享相同的文件对象引用</li>
</ul>
<h4 id="错误处理"><a class="doc-anchor" href="#错误处理">§</a>错误处理</h4>
<p>文件描述符操作可能出现的错误：</p>
<ul>
<li><strong>EBADF</strong>: 文件描述符无效或未打开</li>
<li><strong>EINVAL</strong>: 不支持的操作（如向stdin写入）</li>
<li><strong>EFAULT</strong>: 用户缓冲区地址无效</li>
</ul>
<h4 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 检查标准文件描述符是否可用
</span><span class="kw">let </span>inner = process.inner_exclusive_access();
<span class="macro">assert!</span>(inner.fd_table[<span class="number">0</span>].is_some()); <span class="comment">// stdin
</span><span class="macro">assert!</span>(inner.fd_table[<span class="number">1</span>].is_some()); <span class="comment">// stdout
</span><span class="macro">assert!</span>(inner.fd_table[<span class="number">2</span>].is_some()); <span class="comment">// stderr

// 分配新的文件描述符
</span><span class="kw">let </span>new_fd = inner.alloc_fd();
inner.fd_table[new_fd] = <span class="prelude-val">Some</span>(file_object);</code></pre></div>
</div><span id="structfield.signals" class="structfield section-header"><a href="#structfield.signals" class="anchor field">§</a><code>signals: <a class="struct" href="../signal/struct.SignalFlags.html" title="struct os::process::signal::SignalFlags">SignalFlags</a></code></span><span id="structfield.signal_mask" class="structfield section-header"><a href="#structfield.signal_mask" class="anchor field">§</a><code>signal_mask: <a class="struct" href="../signal/struct.SignalFlags.html" title="struct os::process::signal::SignalFlags">SignalFlags</a></code></span><span id="structfield.handling_sig" class="structfield section-header"><a href="#structfield.handling_sig" class="anchor field">§</a><code>handling_sig: isize</code></span><span id="structfield.signal_actions" class="structfield section-header"><a href="#structfield.signal_actions" class="anchor field">§</a><code>signal_actions: <a class="struct" href="../signal/struct.SignalActions.html" title="struct os::process::signal::SignalActions">SignalActions</a></code></span><span id="structfield.killed" class="structfield section-header"><a href="#structfield.killed" class="anchor field">§</a><code>killed: bool</code></span><span id="structfield.frozen" class="structfield section-header"><a href="#structfield.frozen" class="anchor field">§</a><code>frozen: bool</code></span><span id="structfield.trap_ctx_backup" class="structfield section-header"><a href="#structfield.trap_ctx_backup" class="anchor field">§</a><code>trap_ctx_backup: Option&lt;<a class="struct" href="../../trap/context/struct.TrapContext.html" title="struct os::trap::context::TrapContext">TrapContext</a>&gt;</code></span><span id="structfield.priority" class="structfield section-header"><a href="#structfield.priority" class="anchor field">§</a><code>priority: usize</code></span><div class="docblock"><p>MLFQ 调度优先级</p>
<p>当前进程在多级反馈队列中的优先级，取值范围 [0, MLFQ_QUEUE_COUNT-1]。</p>
<ul>
<li>0: 最高优先级（新进程、I/O密集型进程）</li>
<li>数值越大优先级越低（CPU密集型进程会逐渐降级）</li>
</ul>
</div><span id="structfield.time_slice_used" class="structfield section-header"><a href="#structfield.time_slice_used" class="anchor field">§</a><code>time_slice_used: usize</code></span><div class="docblock"><p>当前时间片已使用的时钟周期数</p>
<p>用于跟踪进程在当前时间片内的CPU使用时间，
当达到该优先级队列的时间片限制时，进程将被降级。</p>
</div><span id="structfield.time_slice_limit" class="structfield section-header"><a href="#structfield.time_slice_limit" class="anchor field">§</a><code>time_slice_limit: usize</code></span><div class="docblock"><p>当前优先级队列的时间片限制</p>
<p>该进程在当前优先级队列中可使用的最大时间片长度，
当 time_slice_used &gt;= time_slice_limit 时触发降级。</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ProcessControlBlockInner" class="impl"><a class="src rightside" href="../../../src/os/process/process.rs.html#583-749">Source</a><a href="#impl-ProcessControlBlockInner" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.trap_cx" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#603-605">Source</a><h4 class="code-header">pub fn <a href="#method.trap_cx" class="fn">trap_cx</a>(&amp;self) -&gt; &amp;'static mut <a class="struct" href="../../trap/context/struct.TrapContext.html" title="struct os::trap::context::TrapContext">TrapContext</a></h4></section></summary><div class="docblock"><p>获取陷阱上下文的可变引用</p>
<p>返回陷阱上下文物理页面的可变引用，用于修改用户态寄存器状态。
陷阱上下文包含用户态所有寄存器的值，用于系统调用和异常处理。</p>
<h6 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h6>
<p>陷阱上下文的可变引用</p>
<h6 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h6>
<p>调用者必须确保陷阱上下文物理页面已正确分配和初始化</p>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>trap_cx = inner.trap_cx();
trap_cx.x[<span class="number">10</span>] = return_value;  <span class="comment">// 设置系统调用返回值</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.user_token" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#622-624">Source</a><h4 class="code-header">pub fn <a href="#method.user_token" class="fn">user_token</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>获取用户地址空间的页表标识符</p>
<p>返回用户地址空间的页表标识符，用于在用户态和内核态之间切换地址空间。
该值通常被编码到 <code>satp</code> 寄存器中。</p>
<h6 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h6>
<p>用户地址空间的页表标识符</p>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>user_token = inner.user_token();
<span class="comment">// 切换到用户地址空间</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.status" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#634-636">Source</a><h4 class="code-header">fn <a href="#method.status" class="fn">status</a>(&amp;self) -&gt; <a class="enum" href="enum.ProcessStatus.html" title="enum os::process::process::ProcessStatus">ProcessStatus</a></h4></section></summary><div class="docblock"><p>获取进程状态</p>
<p>返回当前进程的状态，为内部使用的辅助方法。
外部代码应该直接访问 <code>process_status</code> 字段。</p>
<h6 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h6>
<p>返回当前的 <a href="enum.ProcessStatus.html" title="enum os::process::process::ProcessStatus"><code>ProcessStatus</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_zombie" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#673-675">Source</a><h4 class="code-header">pub fn <a href="#method.is_zombie" class="fn">is_zombie</a>(&amp;self) -&gt; bool</h4></section></summary><div class="docblock"><p>检查进程是否为僵尸状态</p>
<p>判断当前进程是否已经退出但尚未被父进程回收。
僵尸进程不会被调度执行，但保留 PCB 以供父进程获取退出信息。</p>
<h6 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h6>
<ul>
<li><code>true</code> - 进程为僵尸状态，等待父进程回收</li>
<li><code>false</code> - 进程不是僵尸状态，可能正在运行或就绪</li>
</ul>
<h6 id="使用场景-1"><a class="doc-anchor" href="#使用场景-1">§</a>使用场景</h6>
<ul>
<li><strong>父进程管理</strong>: 父进程检查子进程是否退出</li>
<li><strong>进程清理</strong>: 系统定期清理僵尸进程</li>
<li><strong>wait 系统调用</strong>: 等待子进程退出的实现</li>
<li><strong>调度器</strong>: 过滤不可调度的进程</li>
</ul>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 检查子进程状态
</span><span class="kw">let </span>parent_inner = parent_process.inner_exclusive_access();
<span class="kw">for </span>child_process <span class="kw">in </span><span class="kw-2">&amp;</span>parent_inner.children {
    <span class="kw">let </span>child_inner = child_process.inner_exclusive_access();
    <span class="kw">if </span>child_inner.is_zombie() {
        <span class="macro">println!</span>(<span class="string">"Child process {} exited with code {}"</span>,
                 child_process.getpid(), child_inner.exit_code);
    }
}

<span class="comment">// 调度器过滤
</span><span class="kw">if </span>!process_inner.is_zombie() {
    ready_queue.push(process);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.alloc_fd" class="method"><a class="src rightside" href="../../../src/os/process/process.rs.html#741-748">Source</a><h4 class="code-header">pub fn <a href="#method.alloc_fd" class="fn">alloc_fd</a>(&amp;mut self) -&gt; usize</h4></section></summary><div class="docblock"><p>分配新的文件描述符</p>
<p>在文件描述符表中查找第一个可用的位置，并返回对应的文件描述符编号。
如果所有现有位置都被占用，则扩展表大小并返回新的文件描述符。</p>
<h6 id="returns-4"><a class="doc-anchor" href="#returns-4">§</a>Returns</h6>
<p>返回新分配的文件描述符编号（非负整数）</p>
<h6 id="分配策略"><a class="doc-anchor" href="#分配策略">§</a>分配策略</h6>
<ol>
<li><strong>查找策略</strong>: 从索引 0 开始查找第一个 <code>None</code> 位置</li>
<li><strong>扩展策略</strong>: 如果所有位置都被占用，则向表末尾添加新的 <code>None</code> 条目</li>
<li><strong>重用策略</strong>: 优先重用已关闭的文件描述符，减少表大小增长</li>
</ol>
<h6 id="分配过程"><a class="doc-anchor" href="#分配过程">§</a>分配过程</h6><div class="example-wrap"><pre class="language-text"><code>文件描述符表状态示例:
┌-─────-┬──-───--┬──--───-┬-─────-┬─────┐
│  fd0  │  fd1   │   fd2  │  fd3  │ fd4 │
├──-───-┼─-────--┼──-──-─-┼──-───-┼─────┤
│ stdin │ stdout │ stderr │ file1 │ None│ ← 返回 fd4
└─-────-┴──-───--┴─-─--───┴─-────-┴─────┘

关闭 fd1 后:
┌-─────-┬──-───--┬──--───-┬-─────-┬─────┐
│  fd0  │  fd1   │   fd2  │  fd3  │ fd4 │
├──-───-┼─-────--┼──-──-─-┼──-───-┼─────┤
│ stdin │ stdout │ stderr │ file1 │ None│ ← 返回 fd1
└─-────-┴──-───--┴─-─--───┴─-────-┴─────┘</code></pre></div><h6 id="使用场景-2"><a class="doc-anchor" href="#使用场景-2">§</a>使用场景</h6>
<ul>
<li><strong>open 系统调用</strong>: 打开新文件时分配文件描述符</li>
<li><strong>dup 系统调用</strong>: 复制文件描述符时分配新的编号</li>
<li><strong>pipe 系统调用</strong>: 创建管道时分配读写端文件描述符</li>
<li><strong>socket 系统调用</strong>: 创建套接字时分配文件描述符</li>
</ul>
<h6 id="并发安全-1"><a class="doc-anchor" href="#并发安全-1">§</a>并发安全</h6>
<p>此方法需要可变访问权限，调用者必须持有 <a href="../../sync/up/struct.UPSafeCell.html" title="struct os::sync::up::UPSafeCell"><code>UPSafeCell</code></a> 的独占锁。
分配过程是原子的，不会与其他进程的文件描述符分配产生冲突。</p>
<h6 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 在 open 系统调用中使用
</span><span class="kw">let </span><span class="kw-2">mut </span>inner = process.inner_exclusive_access();
<span class="kw">let </span>new_fd = inner.alloc_fd();
inner.fd_table[new_fd] = <span class="prelude-val">Some</span>(file_object);
<span class="kw">return </span>new_fd <span class="kw">as </span>isize;

<span class="comment">// 检查分配结果
</span><span class="macro">println!</span>(<span class="string">"Allocated file descriptor: {}"</span>, new_fd);
<span class="macro">assert!</span>(new_fd &lt; inner.fd_table.len());</code></pre></div>
<h6 id="性能特性"><a class="doc-anchor" href="#性能特性">§</a>性能特性</h6>
<ul>
<li><strong>时间复杂度</strong>: O(n)，其中 n 是文件描述符表的当前大小</li>
<li><strong>空间复杂度</strong>: 最坏情况下需要扩展表大小</li>
<li><strong>内存效率</strong>: 优先重用已关闭的描述符，减少内存浪费</li>
</ul>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-ProcessControlBlockInner" class="impl"><a href="#impl-Freeze-for-ProcessControlBlockInner" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a></h3></section><section id="impl-RefUnwindSafe-for-ProcessControlBlockInner" class="impl"><a href="#impl-RefUnwindSafe-for-ProcessControlBlockInner" class="anchor">§</a><h3 class="code-header">impl !RefUnwindSafe for <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a></h3></section><section id="impl-Send-for-ProcessControlBlockInner" class="impl"><a href="#impl-Send-for-ProcessControlBlockInner" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a></h3></section><section id="impl-Sync-for-ProcessControlBlockInner" class="impl"><a href="#impl-Sync-for-ProcessControlBlockInner" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a></h3></section><section id="impl-Unpin-for-ProcessControlBlockInner" class="impl"><a href="#impl-Unpin-for-ProcessControlBlockInner" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a></h3></section><section id="impl-UnwindSafe-for-ProcessControlBlockInner" class="impl"><a href="#impl-UnwindSafe-for-ProcessControlBlockInner" class="anchor">§</a><h3 class="code-header">impl !UnwindSafe for <a class="struct" href="struct.ProcessControlBlockInner.html" title="struct os::process::process::ProcessControlBlockInner">ProcessControlBlockInner</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>