(function() {
    var type_impls = Object.fromEntries([["os",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-BlockDevice-for-VirtIOBlock\" class=\"impl\"><a class=\"src rightside\" href=\"src/os/drivers/block/virtio_blk.rs.html#99-165\">Source</a><a href=\"#impl-BlockDevice-for-VirtIOBlock\" class=\"anchor\">§</a><h3 class=\"code-header\">impl BlockDevice for <a class=\"struct\" href=\"os/drivers/block/virtio_blk/struct.VirtIOBlock.html\" title=\"struct os::drivers::block::virtio_blk::VirtIOBlock\">VirtIOBlock</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_block\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/os/drivers/block/virtio_blk.rs.html#126-131\">Source</a><a href=\"#method.read_block\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_block</a>(&amp;self, block_id: usize, buf: &amp;mut [u8])</h4></section></summary><div class=\"docblock\"><p>从块设备读取数据</p>\n<p>从指定的块 ID 读取数据到提供的缓冲区中。该操作是原子的，\n要么读取整个块的数据，要么失败。</p>\n<h6 id=\"arguments\"><a class=\"doc-anchor\" href=\"#arguments\">§</a>Arguments</h6>\n<ul>\n<li><code>block_id</code> - 要读取的块 ID</li>\n<li><code>buf</code> - 用于存储读取数据的缓冲区</li>\n</ul>\n<h6 id=\"行为\"><a class=\"doc-anchor\" href=\"#行为\">§</a>行为</h6>\n<ul>\n<li>从 VirtIO 块设备读取指定块的数据</li>\n<li>将数据写入提供的缓冲区</li>\n<li>如果缓冲区大小小于块大小，只读取缓冲区能容纳的数据</li>\n<li>如果缓冲区大小大于块大小，多余部分保持不变</li>\n</ul>\n<h6 id=\"错误处理\"><a class=\"doc-anchor\" href=\"#错误处理\">§</a>错误处理</h6>\n<p>如果读取操作失败，会触发 panic 并显示错误信息。\n这通常表示设备硬件错误或协议错误。</p>\n<h6 id=\"性能说明\"><a class=\"doc-anchor\" href=\"#性能说明\">§</a>性能说明</h6>\n<p>该操作通过 VirtIO 协议进行，支持 DMA 传输，具有较高的性能。\n读取操作是同步的，会阻塞直到数据传输完成。</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_block\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/os/drivers/block/virtio_blk.rs.html#159-164\">Source</a><a href=\"#method.write_block\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_block</a>(&amp;self, block_id: usize, buf: &amp;[u8])</h4></section></summary><div class=\"docblock\"><p>向块设备写入数据</p>\n<p>将缓冲区中的数据写入指定的块 ID。该操作是原子的，\n要么完全写入成功，要么完全失败。</p>\n<h6 id=\"arguments-1\"><a class=\"doc-anchor\" href=\"#arguments-1\">§</a>Arguments</h6>\n<ul>\n<li><code>block_id</code> - 要写入的块 ID</li>\n<li><code>buf</code> - 包含要写入数据的缓冲区</li>\n</ul>\n<h6 id=\"行为-1\"><a class=\"doc-anchor\" href=\"#行为-1\">§</a>行为</h6>\n<ul>\n<li>将缓冲区数据写入指定的块</li>\n<li>如果缓冲区大小小于块大小，块中未覆盖的部分保持不变</li>\n<li>如果缓冲区大小大于块大小，只写入块能容纳的数据</li>\n<li>写入操作完成后，数据立即可用于后续的读取操作</li>\n</ul>\n<h6 id=\"错误处理-1\"><a class=\"doc-anchor\" href=\"#错误处理-1\">§</a>错误处理</h6>\n<p>如果写入操作失败，会触发 panic 并显示错误信息。\n这通常表示设备硬件错误、存储空间不足或协议错误。</p>\n<h6 id=\"持久化\"><a class=\"doc-anchor\" href=\"#持久化\">§</a>持久化</h6>\n<p>写入的数据会立即持久化到存储设备，在系统重启后仍然可用。\n写入操作会刷新设备缓存，确保数据安全。</p>\n</div></details></div></details>","BlockDevice","os::board::BlockDeviceImpl"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-VirtIOBlock\" class=\"impl\"><a class=\"src rightside\" href=\"src/os/drivers/block/virtio_blk.rs.html#167-210\">Source</a><a href=\"#impl-VirtIOBlock\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"os/drivers/block/virtio_blk/struct.VirtIOBlock.html\" title=\"struct os::drivers::block::virtio_blk::VirtIOBlock\">VirtIOBlock</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><a class=\"src rightside\" href=\"src/os/drivers/block/virtio_blk.rs.html#203-209\">Source</a><h4 class=\"code-header\">pub fn <a href=\"os/drivers/block/virtio_blk/struct.VirtIOBlock.html#tymethod.new\" class=\"fn\">new</a>() -&gt; Self</h4></section></summary><div class=\"docblock\"><p>创建新的 VirtIO 块设备实例</p>\n<p>初始化 VirtIO 块设备，建立与硬件设备的连接。\n该函数会配置设备寄存器，建立 VirtIO 队列，并完成设备初始化。</p>\n<h6 id=\"初始化过程\"><a class=\"doc-anchor\" href=\"#初始化过程\">§</a>初始化过程</h6>\n<ol>\n<li><strong>设备发现</strong>: 通过内存映射 I/O 访问设备寄存器</li>\n<li><strong>协议协商</strong>: 与设备协商 VirtIO 协议版本和功能特性</li>\n<li><strong>队列设置</strong>: 建立 VirtIO 队列用于数据传输</li>\n<li><strong>驱动激活</strong>: 激活设备，使其准备好处理 I/O 请求</li>\n</ol>\n<h6 id=\"returns\"><a class=\"doc-anchor\" href=\"#returns\">§</a>Returns</h6>\n<p>返回新创建的 <code>VirtIOBlock</code> 实例，包装在 <code>UPSafeCell</code> 中以支持内部可变性</p>\n<h6 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h6>\n<p>该函数使用 <code>unsafe</code> 代码访问硬件寄存器，调用者必须确保：</p>\n<ul>\n<li>硬件设备已正确初始化并可用</li>\n<li>内存映射 I/O 地址有效且可访问</li>\n<li>没有其他代码同时访问同一设备</li>\n</ul>\n<h6 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h6>\n<p>如果设备初始化失败（如设备不存在、协议不兼容等），会触发 panic。\n这通常表示硬件配置错误或设备驱动问题。</p>\n<h6 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>virtio_block = VirtIOBlock::new();\n<span class=\"comment\">// 现在可以使用 virtio_block 进行块设备操作</span></code></pre></div>\n</div></details></div></details>",0,"os::board::BlockDeviceImpl"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[6698]}