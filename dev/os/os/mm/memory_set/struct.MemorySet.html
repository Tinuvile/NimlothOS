<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="内存集合（地址空间）"><title>MemorySet in os::mm::memory_set - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="os" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (ce36a966c 2025-02-17)" data-channel="nightly" data-search-js="search-f7327375.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5332ae0c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../os/index.html">os</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Memory<wbr>Set</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#组成部分" title="组成部分">组成部分</a></li><li><a href="#生命周期管理" title="生命周期管理">生命周期管理</a></li><li><a href="#并发安全" title="并发安全">并发安全</a></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.areas" title="areas">areas</a></li><li><a href="#structfield.page_table" title="page_table">page_table</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.activate" title="activate">activate</a></li><li><a href="#method.from_elf" title="from_elf">from_elf</a></li><li><a href="#method.from_existed_user" title="from_existed_user">from_existed_user</a></li><li><a href="#method.insert_framed_area" title="insert_framed_area">insert_framed_area</a></li><li><a href="#method.map_trampoline" title="map_trampoline">map_trampoline</a></li><li><a href="#method.new_bare" title="new_bare">new_bare</a></li><li><a href="#method.new_kernel" title="new_kernel">new_kernel</a></li><li><a href="#method.push" title="push">push</a></li><li><a href="#method.recycle_data_pages" title="recycle_data_pages">recycle_data_pages</a></li><li><a href="#method.remove_area_with_start_vpn" title="remove_area_with_start_vpn">remove_area_with_start_vpn</a></li><li><a href="#method.token" title="token">token</a></li><li><a href="#method.translate" title="translate">translate</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-MemorySet" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-MemorySet" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-MemorySet" title="Send">Send</a></li><li><a href="#impl-Sync-for-MemorySet" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-MemorySet" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-MemorySet" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In os::<wbr>mm::<wbr>memory_<wbr>set</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">os</a>::<wbr><a href="../index.html">mm</a>::<wbr><a href="index.html">memory_set</a></div><h1>Struct <span class="struct">MemorySet</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/os/mm/memory_set.rs.html#175-178">Source</a> </span></div><pre class="rust item-decl"><code>pub struct MemorySet {
    page_table: <a class="struct" href="../page_table/struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a>,
    areas: Vec&lt;<a class="struct" href="struct.MapArea.html" title="struct os::mm::memory_set::MapArea">MapArea</a>&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>内存集合（地址空间）</p>
<p>表示一个完整的虚拟地址空间，包含页表和多个内存映射区域。
每个进程都有独立的 <code>MemorySet</code>，实现地址空间隔离。</p>
<h3 id="组成部分"><a class="doc-anchor" href="#组成部分">§</a>组成部分</h3>
<ul>
<li><code>page_table</code>: 多级页表，负责虚拟地址到物理地址的转换</li>
<li><code>areas</code>: 内存映射区域列表，每个区域有独立的映射类型和权限</li>
</ul>
<h3 id="生命周期管理"><a class="doc-anchor" href="#生命周期管理">§</a>生命周期管理</h3>
<p><code>MemorySet</code> 拥有其包含的所有页表和物理页帧，当对象被销毁时，
会自动释放相关的物理内存资源，确保内存安全。</p>
<h3 id="并发安全"><a class="doc-anchor" href="#并发安全">§</a>并发安全</h3>
<p>内核地址空间通过 <code>KERNEL_SPACE</code> 全局变量管理，使用 <code>UPSafeCell</code>
提供单处理器环境下的安全可变访问。</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.page_table" class="structfield section-header"><a href="#structfield.page_table" class="anchor field">§</a><code>page_table: <a class="struct" href="../page_table/struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></code></span><span id="structfield.areas" class="structfield section-header"><a href="#structfield.areas" class="anchor field">§</a><code>areas: Vec&lt;<a class="struct" href="struct.MapArea.html" title="struct os::mm::memory_set::MapArea">MapArea</a>&gt;</code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-MemorySet" class="impl"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#694-1541">Source</a><a href="#impl-MemorySet" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new_bare" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#726-731">Source</a><h4 class="code-header">pub fn <a href="#method.new_bare" class="fn">new_bare</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>创建空的地址空间</p>
<p>创建一个仅包含空页表和空区域列表的地址空间。这是构建
复杂地址空间的基础，需要后续添加具体的内存区域。</p>
<h6 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h6>
<p>新创建的空地址空间，不包含任何内存映射</p>
<h6 id="初始状态"><a class="doc-anchor" href="#初始状态">§</a>初始状态</h6>
<ul>
<li><code>page_table</code>: 新的空页表，仅包含根页表</li>
<li><code>areas</code>: 空的区域列表</li>
</ul>
<h6 id="使用场景"><a class="doc-anchor" href="#使用场景">§</a>使用场景</h6>
<ul>
<li>构建用户程序地址空间</li>
<li>构建内核地址空间的基础</li>
<li>清理和重建地址空间</li>
</ul>
<h6 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>memory_set = MemorySet::new_bare();
<span class="comment">// 添加具体的内存区域...
</span>memory_set.insert_framed_area(
    VirtAddr::from(<span class="number">0x10000000</span>),
    VirtAddr::from(<span class="number">0x10001000</span>),
    MapPermission::R | MapPermission::W | MapPermission::U
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#759-765">Source</a><h4 class="code-header">fn <a href="#method.push" class="fn">push</a>(&amp;mut self, map_area: <a class="struct" href="struct.MapArea.html" title="struct os::mm::memory_set::MapArea">MapArea</a>, data: Option&lt;&amp;[u8]&gt;)</h4></section></summary><div class="docblock"><p>将内存区域添加到地址空间</p>
<p>将一个内存映射区域添加到当前地址空间中，并可选地将数据复制到该区域。
这是地址空间构建的核心操作。</p>
<h6 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h6>
<ul>
<li><code>map_area</code> - 要添加的内存映射区域</li>
<li><code>data</code> - 可选的初始化数据（如 ELF 段数据）</li>
</ul>
<h6 id="操作流程"><a class="doc-anchor" href="#操作流程">§</a>操作流程</h6>
<ol>
<li><strong>建立映射</strong>: 调用 <code>map_area.map()</code> 在页表中建立所有页面映射</li>
<li><strong>复制数据</strong>: 如果提供了数据，将其复制到映射的内存区域</li>
<li><strong>记录区域</strong>: 将区域添加到 <code>areas</code> 列表中以便管理</li>
</ol>
<h6 id="内存安全"><a class="doc-anchor" href="#内存安全">§</a>内存安全</h6>
<ul>
<li>区域被添加到 <code>areas</code> 列表后，其生命周期由 <code>MemorySet</code> 管理</li>
<li>当 <code>MemorySet</code> 被销毁时，所有区域的映射和页帧会自动清理</li>
</ul>
<h6 id="使用场景-1"><a class="doc-anchor" href="#使用场景-1">§</a>使用场景</h6>
<ul>
<li>添加 ELF 文件的代码段和数据段</li>
<li>添加用户栈区域</li>
<li>添加内核的各个逻辑段</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert_framed_area" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#809-816">Source</a><h4 class="code-header">pub fn <a href="#method.insert_framed_area" class="fn">insert_framed_area</a>(
    &amp;mut self,
    start_va: <a class="struct" href="../address/struct.VirtAddr.html" title="struct os::mm::address::VirtAddr">VirtAddr</a>,
    end_va: <a class="struct" href="../address/struct.VirtAddr.html" title="struct os::mm::address::VirtAddr">VirtAddr</a>,
    perm: <a class="struct" href="struct.MapPermission.html" title="struct os::mm::memory_set::MapPermission">MapPermission</a>,
)</h4></section></summary><div class="docblock"><p>插入帧映射内存区域</p>
<p>在地址空间中添加一个使用 Framed 映射类型的内存区域。
该区域的每个页面都会分配独立的物理页帧。</p>
<h6 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h6>
<ul>
<li><code>start_va</code> - 区域起始虚拟地址</li>
<li><code>end_va</code> - 区域结束虚拟地址（不包含）</li>
<li><code>perm</code> - 内存访问权限</li>
</ul>
<h6 id="特点"><a class="doc-anchor" href="#特点">§</a>特点</h6>
<ul>
<li><strong>独立分配</strong>: 每个虚拟页面对应一个新分配的物理页帧</li>
<li><strong>地址隔离</strong>: 虚拟地址和物理地址没有固定关系</li>
<li><strong>内存保护</strong>: 支持完整的内存访问权限控制</li>
<li><strong>自动清理</strong>: 区域销毁时自动释放所有物理页帧</li>
</ul>
<h6 id="使用场景-2"><a class="doc-anchor" href="#使用场景-2">§</a>使用场景</h6>
<ul>
<li>用户程序的堆区域</li>
<li>用户程序的栈区域</li>
<li>内核的动态内存区域</li>
<li>需要地址隔离的任何区域</li>
</ul>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 添加用户态可读写区域
</span>memory_set.insert_framed_area(
    VirtAddr::from(<span class="number">0x10000000</span>),
    VirtAddr::from(<span class="number">0x10001000</span>),
    MapPermission::R | MapPermission::W | MapPermission::U
);

<span class="comment">// 添加用户栈区域
</span>memory_set.insert_framed_area(
    VirtAddr::from(USER_STACK_BASE),
    VirtAddr::from(USER_STACK_BASE + USER_STACK_SIZE),
    MapPermission::R | MapPermission::W | MapPermission::U
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map_trampoline" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#839-845">Source</a><h4 class="code-header">fn <a href="#method.map_trampoline" class="fn">map_trampoline</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>映射 Trampoline 页面</p>
<p>在地址空间的高地址区域映射 Trampoline 页面，用于内核态和用户态之间的
上下文切换。Trampoline 是一个特殊的汇编代码段，在所有地址空间中都映射到
同一个物理地址。</p>
<h6 id="映射特点"><a class="doc-anchor" href="#映射特点">§</a>映射特点</h6>
<ul>
<li><strong>虚拟地址</strong>: <code>TRAMPOLINE</code> 常量定义的高地址</li>
<li><strong>物理地址</strong>: <code>strampoline</code> 符号指向的物理地址</li>
<li><strong>权限</strong>: 可读 + 可执行（<code>R | X</code>）</li>
<li><strong>共享</strong>: 所有地址空间都映射到同一物理页面</li>
</ul>
<h6 id="作用"><a class="doc-anchor" href="#作用">§</a>作用</h6>
<p>Trampoline 允许在地址空间切换过程中继续执行代码，解决了
在切换 <code>satp</code> 寄存器后指令取指地址变化的问题。</p>
<h6 id="安全性"><a class="doc-anchor" href="#安全性">§</a>安全性</h6>
<p>Trampoline 代码经过精心设计，不会泄露内核信息给用户程序。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_kernel" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#890-963">Source</a><h4 class="code-header">pub fn <a href="#method.new_kernel" class="fn">new_kernel</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>创建内核地址空间</p>
<p>构建完整的内核地址空间，包括内核的各个逻辑段（.text、.rodata、.data、.bss）
以及物理内存映射区域和 Trampoline。所有内核段都使用恒等映射，确保虚拟地址
等于物理地址，便于内核直接访问物理内存。</p>
<h6 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h6>
<p>完整配置的内核地址空间，包含所有必要的内存映射</p>
<h6 id="内核段映射"><a class="doc-anchor" href="#内核段映射">§</a>内核段映射</h6><div><table><thead><tr><th>段名称</th><th>权限</th><th>映射类型</th><th>用途</th></tr></thead><tbody>
<tr><td>.text</td><td>R+X</td><td>Identical</td><td>内核代码段</td></tr>
<tr><td>.rodata</td><td>R</td><td>Identical</td><td>只读数据段</td></tr>
<tr><td>.data</td><td>R+W</td><td>Identical</td><td>已初始化数据段</td></tr>
<tr><td>.bss</td><td>R+W</td><td>Identical</td><td>未初始化数据段</td></tr>
<tr><td>Physical Memory</td><td>R+W</td><td>Identical</td><td>物理内存直接映射</td></tr>
<tr><td>Trampoline</td><td>R+X</td><td>Identical</td><td>上下文切换代码</td></tr>
</tbody></table>
</div><h6 id="地址范围"><a class="doc-anchor" href="#地址范围">§</a>地址范围</h6>
<ul>
<li><strong>内核段</strong>: 由链接器脚本 <code>linker-qemu.ld</code> 定义的符号确定边界</li>
<li><strong>物理内存</strong>: 从 <code>ekernel</code> 到 <code>MEMORY_END</code> 的整个可用物理内存</li>
<li><strong>Trampoline</strong>: 固定映射到 <code>TRAMPOLINE</code> 虚拟地址</li>
</ul>
<h6 id="调试输出"><a class="doc-anchor" href="#调试输出">§</a>调试输出</h6>
<p>函数会打印各个段的地址范围，便于调试和验证内存布局。</p>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 创建内核地址空间（通常在系统初始化时调用）
</span><span class="kw">let </span>kernel_space = MemorySet::new_kernel();

<span class="comment">// 输出示例：
// .text [0x80200000, 0x80210000)
// .rodata [0x80210000, 0x80220000)
// .data [0x80220000, 0x80230000)
// .bss [0x80230000, 0x80240000)</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_elf" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#1042-1121">Source</a><h4 class="code-header">pub fn <a href="#method.from_elf" class="fn">from_elf</a>(elf_data: &amp;[u8]) -&gt; (Self, usize, usize)</h4></section></summary><div class="docblock"><p>从 ELF 文件创建用户地址空间</p>
<p>解析 ELF 文件并构建相应的用户程序地址空间，包括程序的各个段、用户栈、
Trap Context 和 Trampoline。所有用户段都使用 Framed 映射，实现地址空间隔离。</p>
<h6 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments</h6>
<ul>
<li><code>elf_data</code> - ELF 文件的二进制数据</li>
</ul>
<h6 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h6>
<p>返回一个三元组：</p>
<ul>
<li><code>MemorySet</code>: 构建好的用户地址空间</li>
<li><code>usize</code>: 用户栈顶地址</li>
<li><code>usize</code>: 程序入口点地址</li>
</ul>
<h6 id="地址空间布局"><a class="doc-anchor" href="#地址空间布局">§</a>地址空间布局</h6><div class="example-wrap"><pre class="language-text"><code>高地址 (TRAMPOLINE)
┌──────────────────────────────────────────────────────┐
│                   Trampoline                         │
│                    (R+X)                             │
├──────────────────────────────────────────────────────┤
│                 Trap Context                         │
│                    (R+W)                             │
├──────────────────────────────────────────────────────┤
│                  User Stack                          │
│                   (R+W+U)                            │
├──────────────────────────────────────────────────────┤
│                  Guard Page                          │
├──────────────────────────────────────────────────────┤
│               ELF Program Sections                   │
│            (.text/.data/.bss etc)                    │
│              (Based on ELF flags)                    │
└──────────────────────────────────────────────────────┘
低地址 (0x10000)</code></pre></div><h6 id="elf-解析过程"><a class="doc-anchor" href="#elf-解析过程">§</a>ELF 解析过程</h6>
<ol>
<li><strong>验证 ELF 魔数</strong>: 确保文件格式正确</li>
<li><strong>解析程序头</strong>: 遍历所有 <code>LOAD</code> 类型的程序段</li>
<li><strong>权限转换</strong>: 将 ELF 段标志转换为 <code>MapPermission</code></li>
<li><strong>段映射</strong>: 为每个段创建 Framed 映射并复制数据</li>
<li><strong>用户栈</strong>: 在程序段之上分配用户栈空间</li>
<li><strong>系统区域</strong>: 映射 Trap Context 和 Trampoline</li>
</ol>
<h6 id="权限映射"><a class="doc-anchor" href="#权限映射">§</a>权限映射</h6>
<p>ELF 段标志到内存权限的转换：</p>
<ul>
<li><code>PF_R</code> → <code>MapPermission::R</code></li>
<li><code>PF_W</code> → <code>MapPermission::W</code></li>
<li><code>PF_X</code> → <code>MapPermission::X</code></li>
<li>所有用户段都包含 <code>MapPermission::U</code></li>
</ul>
<h6 id="内存安全-1"><a class="doc-anchor" href="#内存安全-1">§</a>内存安全</h6>
<ul>
<li>所有用户段使用 Framed 映射，与内核地址空间完全隔离</li>
<li>用户栈与程序段之间有保护页面防止栈溢出</li>
<li>Trap Context 仅内核可写，用户只读</li>
</ul>
<h6 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h6>
<ul>
<li>ELF 魔数验证失败</li>
<li>ELF 文件格式错误</li>
<li>物理页帧分配失败</li>
</ul>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>app_data = get_app_data(<span class="number">0</span>); <span class="comment">// 获取应用程序 ELF 数据
</span><span class="kw">let </span>(memory_set, user_stack_top, entry_point) = MemorySet::from_elf(app_data);

<span class="macro">println!</span>(<span class="string">"Entry point: {:#x}"</span>, entry_point);
<span class="macro">println!</span>(<span class="string">"User stack top: {:#x}"</span>, user_stack_top);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.activate" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#1167-1173">Source</a><h4 class="code-header">pub fn <a href="#method.activate" class="fn">activate</a>(&amp;self)</h4></section></summary><div class="docblock"><p>激活地址空间</p>
<p>将当前地址空间设置为活跃的地址空间，启用该地址空间的页表进行
地址转换。这是地址空间切换的核心操作。</p>
<h6 id="操作流程-1"><a class="doc-anchor" href="#操作流程-1">§</a>操作流程</h6>
<ol>
<li><strong>获取页表标识</strong>: 调用 <code>page_table.token()</code> 获取 <code>satp</code> 寄存器值</li>
<li><strong>设置 satp</strong>: 将页表标识写入 <code>satp</code> 寄存器</li>
<li><strong>刷新 TLB</strong>: 执行 <code>sfence.vma</code> 指令清空 TLB 缓存</li>
</ol>
<h6 id="satp-寄存器格式"><a class="doc-anchor" href="#satp-寄存器格式">§</a>satp 寄存器格式</h6><div class="example-wrap"><pre class="language-text"><code>┌─────────────┬─────────────────┬─────────────────────────────────────────────┐
│    MODE     │      ASID       │                    PPN                      │
│   (4bit)    │     (16bit)     │                  (44bit)                    │
└─────────────┴─────────────────┴─────────────────────────────────────────────┘</code></pre></div><h6 id="安全性-1"><a class="doc-anchor" href="#安全性-1">§</a>安全性</h6>
<p>此操作使用 <code>unsafe</code> 代码，因为：</p>
<ul>
<li>直接操作系统寄存器</li>
<li>执行特权指令</li>
<li>可能影响所有后续的内存访问</li>
</ul>
<h6 id="使用场景-3"><a class="doc-anchor" href="#使用场景-3">§</a>使用场景</h6>
<ul>
<li>系统初始化时激活内核地址空间</li>
<li>进程切换时激活用户地址空间</li>
<li>从用户态返回内核态时恢复内核地址空间</li>
</ul>
<h6 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 激活内核地址空间
</span><span class="kw">let </span>kernel_space = KERNEL_SPACE.exclusive_access();
kernel_space.activate();

<span class="comment">// 激活用户地址空间
</span><span class="kw">let </span>user_space = task.get_user_space();
user_space.activate();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.translate" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#1215-1217">Source</a><h4 class="code-header">pub fn <a href="#method.translate" class="fn">translate</a>(&amp;self, vpn: <a class="struct" href="../address/struct.VirtPageNum.html" title="struct os::mm::address::VirtPageNum">VirtPageNum</a>) -&gt; Option&lt;<a class="struct" href="../page_table/struct.PageTableEntry.html" title="struct os::mm::page_table::PageTableEntry">PageTableEntry</a>&gt;</h4></section></summary><div class="docblock"><p>转换虚拟页号到页表项</p>
<p>通过地址空间的页表将虚拟页号转换为对应的页表项。
返回的页表项包含物理页号和权限信息。</p>
<h6 id="arguments-3"><a class="doc-anchor" href="#arguments-3">§</a>Arguments</h6>
<ul>
<li><code>vpn</code> - 要转换的虚拟页号</li>
</ul>
<h6 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h6>
<ul>
<li><code>Some(PageTableEntry)</code> - 找到对应的页表项</li>
<li><code>None</code> - 虚拟页号未被映射</li>
</ul>
<h6 id="转换过程"><a class="doc-anchor" href="#转换过程">§</a>转换过程</h6>
<ol>
<li>从虚拟页号提取三级页表索引</li>
<li>从根页表开始逐级遍历</li>
<li>检查每级页表项的有效性</li>
<li>返回最终的叶子页表项</li>
</ol>
<h6 id="使用场景-4"><a class="doc-anchor" href="#使用场景-4">§</a>使用场景</h6>
<ul>
<li>手动地址转换和验证</li>
<li>内存访问权限检查</li>
<li>调试和诊断工具</li>
<li>页面故障处理</li>
</ul>
<h6 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>vpn = VirtPageNum(<span class="number">0x10000</span>);
<span class="kw">if let </span><span class="prelude-val">Some</span>(pte) = memory_set.translate(vpn) {
    <span class="kw">let </span>ppn = pte.ppn();
    <span class="kw">let </span>readable = pte.readable();
    <span class="macro">println!</span>(<span class="string">"VPN {:#x} -&gt; PPN {:#x}, readable: {}"</span>, vpn.<span class="number">0</span>, ppn.<span class="number">0</span>, readable);
} <span class="kw">else </span>{
    <span class="macro">println!</span>(<span class="string">"VPN {:#x} not mapped"</span>, vpn.<span class="number">0</span>);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.token" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#1262-1264">Source</a><h4 class="code-header">pub fn <a href="#method.token" class="fn">token</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>获取地址空间的页表标识符</p>
<p>返回当前地址空间的页表标识符（<code>satp</code> 寄存器值），用于地址空间切换
和页表管理。该标识符包含页表模式、ASID 和根页表物理页号信息。</p>
<h6 id="returns-4"><a class="doc-anchor" href="#returns-4">§</a>Returns</h6>
<p><code>usize</code> - 页表标识符，可直接写入 <code>satp</code> 寄存器</p>
<h6 id="satp-寄存器格式-1"><a class="doc-anchor" href="#satp-寄存器格式-1">§</a>satp 寄存器格式</h6><div class="example-wrap"><pre class="language-text"><code>┌─────────────┬─────────────────┬─────────────────────────────────────────────┐
│    MODE     │      ASID       │                    PPN                      │
│   (4bit)    │     (16bit)     │                  (44bit)                    │
└─────────────┴─────────────────┴─────────────────────────────────────────────┘</code></pre></div><h6 id="使用场景-5"><a class="doc-anchor" href="#使用场景-5">§</a>使用场景</h6>
<ul>
<li><strong>地址空间切换</strong>: 进程切换时设置新的页表</li>
<li><strong>陷阱上下文</strong>: 保存当前地址空间标识符</li>
<li><strong>调试和监控</strong>: 获取当前活跃的页表信息</li>
</ul>
<h6 id="与-activate-的关系"><a class="doc-anchor" href="#与-activate-的关系">§</a>与 <code>activate()</code> 的关系</h6>
<p><code>token()</code> 获取标识符，<code>activate()</code> 使用标识符：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>token = memory_set.token();  <span class="comment">// 获取标识符
// ... 可以保存 token 供后续使用
</span>memory_set.activate();           <span class="comment">// 激活地址空间（内部调用 token()）</span></code></pre></div>
<h6 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 获取内核地址空间标识符
</span><span class="kw">let </span>kernel_token = KERNEL_SPACE.exclusive_access().token();

<span class="comment">// 在任务切换中使用
</span><span class="kw">let </span>user_token = task.memory_set.token();
<span class="comment">// 保存到陷阱上下文中...</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove_area_with_start_vpn" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#1342-1352">Source</a><h4 class="code-header">pub fn <a href="#method.remove_area_with_start_vpn" class="fn">remove_area_with_start_vpn</a>(&amp;mut self, start_vpn: <a class="struct" href="../address/struct.VirtPageNum.html" title="struct os::mm::address::VirtPageNum">VirtPageNum</a>)</h4></section></summary><div class="docblock"><p>移除指定起始虚拟页号的内存区域</p>
<p>查找并移除地址空间中以指定虚拟页号开始的内存映射区域。
这是一个精确匹配操作，只有起始页号完全一致的区域才会被移除。</p>
<h6 id="arguments-4"><a class="doc-anchor" href="#arguments-4">§</a>Arguments</h6>
<ul>
<li><code>start_vpn</code> - 要移除区域的起始虚拟页号</li>
</ul>
<h6 id="操作流程-2"><a class="doc-anchor" href="#操作流程-2">§</a>操作流程</h6>
<ol>
<li><strong>查找区域</strong>: 在 <code>areas</code> 列表中查找起始页号匹配的区域</li>
<li><strong>取消映射</strong>: 调用区域的 <code>unmap()</code> 方法清理所有页表映射</li>
<li><strong>移除区域</strong>: 从 <code>areas</code> 列表中删除该区域</li>
<li><strong>资源清理</strong>: 通过 RAII 机制自动释放相关的物理页帧</li>
</ol>
<h6 id="资源管理"><a class="doc-anchor" href="#资源管理">§</a>资源管理</h6><h6 id="页表清理"><a class="doc-anchor" href="#页表清理">§</a>页表清理</h6>
<ul>
<li>移除区域内所有虚拟页面的页表项</li>
<li>确保后续访问这些地址会触发页面异常</li>
</ul>
<h6 id="物理内存释放"><a class="doc-anchor" href="#物理内存释放">§</a>物理内存释放</h6>
<ul>
<li>Framed 映射：自动释放所有分配的物理页帧</li>
<li>Identical 映射：仅清理页表项，不释放物理页面</li>
</ul>
<h6 id="使用场景-6"><a class="doc-anchor" href="#使用场景-6">§</a>使用场景</h6>
<ul>
<li><strong>内存映射文件卸载</strong>: 取消文件映射区域</li>
<li><strong>动态库卸载</strong>: 移除动态加载的代码段和数据段</li>
<li><strong>堆空间管理</strong>: 移除不再使用的堆区域</li>
<li><strong>进程清理</strong>: 进程退出时清理特定内存区域</li>
</ul>
<h6 id="安全性-2"><a class="doc-anchor" href="#安全性-2">§</a>安全性</h6>
<p>函数会安全处理以下情况：</p>
<ul>
<li>如果未找到匹配的区域，函数静默返回，不会产生错误</li>
<li>所有相关的物理页帧会通过 <code>FrameTracker</code> 的析构函数自动释放</li>
<li>页表项的清理确保了后续访问的安全性</li>
</ul>
<h6 id="内存布局影响"><a class="doc-anchor" href="#内存布局影响">§</a>内存布局影响</h6><div class="example-wrap"><pre class="language-text"><code>移除前的地址空间:
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│ Area A   │ │ Area B   │ │ Area C   │ │ Area D   │
│ VPN:100  │ │ VPN:200  │ │ VPN:300  │ │ VPN:400  │
└──────────┘ └──────────┘ └──────────┘ └──────────┘

remove_area_with_start_vpn(VirtPageNum(200)) 后:
┌──────────┐              ┌──────────┐ ┌──────────┐
│ Area A   │     Empty    │ Area C   │ │ Area D   │
│ VPN:100  │              │ VPN:300  │ │ VPN:400  │
└──────────┘              └──────────┘ └──────────┘</code></pre></div><h6 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 移除特定的内存映射区域
</span><span class="kw">let </span>heap_start = VirtPageNum(<span class="number">0x10000</span>); <span class="comment">// 堆区域起始页号
</span>memory_set.remove_area_with_start_vpn(heap_start);
<span class="comment">// 堆区域被移除，相关物理页帧被释放

// 移除动态加载的库
</span><span class="kw">let </span>lib_start = VirtPageNum(<span class="number">0x40000000 </span>&gt;&gt; <span class="number">12</span>); <span class="comment">// 库加载地址
</span>memory_set.remove_area_with_start_vpn(lib_start);
<span class="comment">// 库的代码段和数据段被完全卸载</span></code></pre></div>
<h6 id="注意事项"><a class="doc-anchor" href="#注意事项">§</a>注意事项</h6>
<ul>
<li>函数使用精确匹配，只有起始页号完全相同的区域才会被移除</li>
<li>移除后该区域的所有虚拟地址将变为无效</li>
<li>如果有代码仍在访问被移除区域，会触发页面异常</li>
<li>建议在移除前确保没有其他代码依赖该区域</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_existed_user" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#1500-1513">Source</a><h4 class="code-header">pub fn <a href="#method.from_existed_user" class="fn">from_existed_user</a>(user_space: &amp;Self) -&gt; Self</h4></section></summary><div class="docblock"><p>从现有用户地址空间创建完全独立的副本</p>
<p>深度复制一个已存在的用户地址空间，创建具有相同内存布局和数据内容
的全新地址空间。这是 fork 系统调用的核心实现，确保父子进程拥有
独立但内容相同的地址空间。</p>
<h6 id="arguments-5"><a class="doc-anchor" href="#arguments-5">§</a>Arguments</h6>
<ul>
<li><code>user_space</code> - 源用户地址空间的引用</li>
</ul>
<h6 id="returns-5"><a class="doc-anchor" href="#returns-5">§</a>Returns</h6>
<p>新创建的地址空间，包含与源空间相同的内存布局和数据</p>
<h6 id="复制过程"><a class="doc-anchor" href="#复制过程">§</a>复制过程</h6><h6 id="1-基础结构复制"><a class="doc-anchor" href="#1-基础结构复制">§</a>1. 基础结构复制</h6><div class="example-wrap"><pre class="language-text"><code>源地址空间                    目标地址空间
┌──────────┐                ┌──────────┐
│PageTable │ ──────────────►│New Table │
├──────────┤                ├──────────┤
│ Area A   │ ──────────────►│ Area A&#39;  │
├──────────┤                ├──────────┤
│ Area B   │ ──────────────►│ Area B&#39;  │
├──────────┤                ├──────────┤
│   ...    │ ──────────────►│   ...    │
└──────────┘                └──────────┘</code></pre></div><h6 id="2-数据复制流程"><a class="doc-anchor" href="#2-数据复制流程">§</a>2. 数据复制流程</h6>
<ol>
<li><strong>创建空地址空间</strong>: 初始化新的页表和区域列表</li>
<li><strong>映射 Trampoline</strong>: 共享系统调用跳板页面</li>
<li><strong>复制区域结构</strong>: 为每个源区域创建对应的新区域</li>
<li><strong>建立页面映射</strong>: 为新区域分配独立的物理页帧</li>
<li><strong>逐页复制数据</strong>: 将源物理页面的内容复制到新页面</li>
</ol>
<h6 id="内存隔离保证"><a class="doc-anchor" href="#内存隔离保证">§</a>内存隔离保证</h6><h6 id="物理页面独立性"><a class="doc-anchor" href="#物理页面独立性">§</a>物理页面独立性</h6>
<ul>
<li><strong>独立分配</strong>: 每个页面都分配新的物理页帧</li>
<li><strong>数据复制</strong>: 逐字节复制源页面内容到新页面</li>
<li><strong>完全隔离</strong>: 修改新地址空间不会影响源地址空间</li>
</ul>
<h6 id="虚拟地址一致性"><a class="doc-anchor" href="#虚拟地址一致性">§</a>虚拟地址一致性</h6>
<ul>
<li><strong>布局保持</strong>: 虚拟地址布局与源空间完全一致</li>
<li><strong>权限复制</strong>: 保持每个区域的原始访问权限</li>
<li><strong>映射类型</strong>: 保持原始的映射类型（通常为 Framed）</li>
</ul>
<h6 id="共享资源"><a class="doc-anchor" href="#共享资源">§</a>共享资源</h6>
<p>只有 <strong>Trampoline</strong> 页面在父子进程间共享：</p>
<ul>
<li>系统调用跳板代码（只读+可执行）</li>
<li>不包含进程私有数据</li>
<li>安全的共享资源</li>
</ul>
<h6 id="性能特征"><a class="doc-anchor" href="#性能特征">§</a>性能特征</h6>
<ul>
<li><strong>时间复杂度</strong>: O(n × p)，其中 n 是区域数量，p 是总页面数</li>
<li><strong>空间复杂度</strong>: O(p)，需要分配与源空间相同数量的物理页面</li>
<li><strong>内存开销</strong>: 完整复制所有用户数据，内存使用翻倍</li>
</ul>
<h6 id="使用场景-7"><a class="doc-anchor" href="#使用场景-7">§</a>使用场景</h6><h6 id="主要用途"><a class="doc-anchor" href="#主要用途">§</a>主要用途</h6>
<ul>
<li><strong>进程 Fork</strong>: 创建子进程的独立地址空间</li>
<li><strong>检查点恢复</strong>: 保存进程状态快照</li>
<li><strong>调试和分析</strong>: 创建进程副本用于分析</li>
</ul>
<h6 id="典型调用序列"><a class="doc-anchor" href="#典型调用序列">§</a>典型调用序列</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 在 fork 系统调用中
</span><span class="kw">let </span>parent_space = current_task.memory_set;
<span class="kw">let </span>child_space = MemorySet::from_existed_user(<span class="kw-2">&amp;</span>parent_space);

<span class="comment">// 创建子进程任务控制块
</span><span class="kw">let </span>child_task = TaskControlBlock::new_with_space(child_space);</code></pre></div>
<h6 id="安全性考虑"><a class="doc-anchor" href="#安全性考虑">§</a>安全性考虑</h6><h6 id="内存安全-2"><a class="doc-anchor" href="#内存安全-2">§</a>内存安全</h6>
<ul>
<li><strong>独立生命周期</strong>: 子地址空间的销毁不影响父进程</li>
<li><strong>访问隔离</strong>: 父子进程无法直接访问对方的物理页面</li>
<li><strong>权限继承</strong>: 子进程继承父进程的内存访问权限</li>
</ul>
<h6 id="数据一致性"><a class="doc-anchor" href="#数据一致性">§</a>数据一致性</h6>
<ul>
<li><strong>原子复制</strong>: 复制过程中源数据保持不变</li>
<li><strong>完整复制</strong>: 所有用户空间数据都被精确复制</li>
<li><strong>状态一致</strong>: 复制时刻的内存状态被完整保留</li>
</ul>
<h6 id="错误处理"><a class="doc-anchor" href="#错误处理">§</a>错误处理</h6>
<p>函数可能在以下情况下 panic：</p>
<ul>
<li>物理页帧分配失败（内存不足）</li>
<li>页表映射操作失败</li>
<li>源地址空间结构损坏</li>
</ul>
<h6 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// fork 系统调用的核心实现
</span><span class="kw">fn </span>sys_fork() -&gt; isize {
    <span class="kw">let </span>current_task = current_task().unwrap();
     
    <span class="comment">// 复制父进程的地址空间
    </span><span class="kw">let </span>parent_space = <span class="kw-2">&amp;</span>current_task.inner_exclusive_access().memory_set;
    <span class="kw">let </span>child_space = MemorySet::from_existed_user(parent_space);
     
    <span class="comment">// 创建子进程...
    </span><span class="kw">let </span>child_task = TaskControlBlock::new_with_space(child_space);
     
    child_task.getpid() <span class="kw">as </span>isize
}</code></pre></div>
<h6 id="内存布局示例"><a class="doc-anchor" href="#内存布局示例">§</a>内存布局示例</h6><div class="example-wrap"><pre class="language-text"><code>Fork 前 - 父进程:
┌──────────────────────────────────────────────────────────┐
│                    Parent Process                        │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────────────┐  │
│  │.text   │  │.data   │  │ Stack  │  │      Heap      │  │
│  │ PPN:A  │  │ PPN:B  │  │ PPN:C  │  │ PPN:D,E,F,...  │  │
│  └────────┘  └────────┘  └────────┘  └────────────────┘  │
└──────────────────────────────────────────────────────────┘

Fork 后 - 父进程和子进程:
┌──────────────────────────────────────────────────────────┐
│                    Parent Process                        │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────────────┐  │
│  │.text   │  │.data   │  │ Stack  │  │      Heap      │  │
│  │ PPN:A  │  │ PPN:B  │  │ PPN:C  │  │ PPN:D,E,F,...  │  │
│  └────────┘  └────────┘  └────────┘  └────────────────┘  │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│                    Child Process                         │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────────────┐  │
│  │.text   │  │.data   │  │ Stack  │  │      Heap      │  │
│  │ PPN:A&#39; │  │ PPN:B&#39; │  │ PPN:C&#39; │  │ PPN:D&#39;,E&#39;,F&#39;.. │  │
│  └────────┘  └────────┘  └────────┘  └────────────────┘  │
└──────────────────────────────────────────────────────────┘
(相同的虚拟地址，不同的物理页面，相同的数据内容)</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.recycle_data_pages" class="method"><a class="src rightside" href="../../../src/os/mm/memory_set.rs.html#1538-1540">Source</a><h4 class="code-header">pub fn <a href="#method.recycle_data_pages" class="fn">recycle_data_pages</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>回收数据页（仅清空区域元数据）</p>
<p>清空 <code>areas</code> 列表中记录的内存映射区域元数据。该操作不会修改页表、不会取消映射、
也不会主动释放任何物理页帧，仅用于丢弃地址空间的“区域描述信息“。</p>
<h6 id="适用场景"><a class="doc-anchor" href="#适用场景">§</a>适用场景</h6>
<ul>
<li>进程退出路径：<code>MemorySet</code> 即将被销毁，相关页帧由 RAII 自动释放</li>
<li>需要快速丢弃区域管理信息，防止后续逻辑再遍历/操作这些区域</li>
</ul>
<h6 id="注意事项-1"><a class="doc-anchor" href="#注意事项-1">§</a>注意事项</h6>
<ul>
<li>不会调用 <code>unmap()</code>：页表映射仍然存在</li>
<li>不会释放物理页帧：仅清空区域列表</li>
<li>仅在后续不再使用该地址空间或即将销毁时调用</li>
<li>若仍需继续使用地址空间，请改用 <code>remove_area_with_start_vpn()</code>/<code>unmap()</code> 等精确接口</li>
</ul>
<h6 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 在进程回收路径中：丢弃区域元数据
</span>memory_set.recycle_data_pages();</code></pre></div>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-MemorySet" class="impl"><a href="#impl-Freeze-for-MemorySet" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></h3></section><section id="impl-RefUnwindSafe-for-MemorySet" class="impl"><a href="#impl-RefUnwindSafe-for-MemorySet" class="anchor">§</a><h3 class="code-header">impl RefUnwindSafe for <a class="struct" href="struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></h3></section><section id="impl-Send-for-MemorySet" class="impl"><a href="#impl-Send-for-MemorySet" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></h3></section><section id="impl-Sync-for-MemorySet" class="impl"><a href="#impl-Sync-for-MemorySet" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></h3></section><section id="impl-Unpin-for-MemorySet" class="impl"><a href="#impl-Unpin-for-MemorySet" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></h3></section><section id="impl-UnwindSafe-for-MemorySet" class="impl"><a href="#impl-UnwindSafe-for-MemorySet" class="anchor">§</a><h3 class="code-header">impl UnwindSafe for <a class="struct" href="struct.MemorySet.html" title="struct os::mm::memory_set::MemorySet">MemorySet</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>