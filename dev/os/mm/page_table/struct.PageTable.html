<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="页表 (Page Table)"><title>PageTable in os::mm::page_table - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="os" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (ce36a966c 2025-02-17)" data-channel="nightly" data-search-js="search-f7327375.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-5332ae0c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../os/index.html">os</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Page<wbr>Table</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#结构组成" title="结构组成">结构组成</a></li><li><a href="#三级页表结构" title="三级页表结构">三级页表结构</a></li><li><a href="#raii-内存管理" title="RAII 内存管理">RAII 内存管理</a></li><li><a href="#使用示例" title="使用示例">使用示例</a></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.frames" title="frames">frames</a></li><li><a href="#structfield.root_ppn" title="root_ppn">root_ppn</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.find_pte" title="find_pte">find_pte</a></li><li><a href="#method.find_pte_create" title="find_pte_create">find_pte_create</a></li><li><a href="#method.from_token" title="from_token">from_token</a></li><li><a href="#method.map" title="map">map</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.token" title="token">token</a></li><li><a href="#method.translate" title="translate">translate</a></li><li><a href="#method.unmap" title="unmap">unmap</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-PageTable" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-PageTable" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-PageTable" title="Send">Send</a></li><li><a href="#impl-Sync-for-PageTable" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-PageTable" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-PageTable" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In os::<wbr>mm::<wbr>page_<wbr>table</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">os</a>::<wbr><a href="../index.html">mm</a>::<wbr><a href="index.html">page_table</a></div><h1>Struct <span class="struct">PageTable</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/os/mm/page_table.rs.html#422-434">Source</a> </span></div><pre class="rust item-decl"><code>pub struct PageTable {
    root_ppn: <a class="struct" href="../address/struct.PhysPageNum.html" title="struct os::mm::address::PhysPageNum">PhysPageNum</a>,
    frames: Vec&lt;<a class="struct" href="../frame_allocator/struct.FrameTracker.html" title="struct os::mm::frame_allocator::FrameTracker">FrameTracker</a>&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>页表 (Page Table)</p>
<p>管理三级页表结构，实现虚拟地址到物理地址的映射机制。
采用 RISC-V SV39 分页方案，支持页面的映射、取消映射和地址转换。</p>
<h3 id="结构组成"><a class="doc-anchor" href="#结构组成">§</a>结构组成</h3>
<ul>
<li><strong>根页表</strong>: 一级页表的物理页号，用于硬件 MMU 查找</li>
<li><strong>页帧管理</strong>: 自动管理所有页表页帧的生命周期</li>
</ul>
<h3 id="三级页表结构"><a class="doc-anchor" href="#三级页表结构">§</a>三级页表结构</h3><div class="example-wrap"><pre class="language-text"><code>Address translation process:
             VPN[2]        VPN[1]          VPN[0]      Offset
             (9bit)        (9bit)          (9bit)      (12bit)
                │            │              │           │
                v            │              │           │
        ┌─────────────┐      │              │           │
   satp │ Level1 PPN  │      │              │           │
        └─────────────┘      │              │           │
                │            │              │           │
                v            v              │           │
        ┌─────────────┐ ┌─────────────┐     │           │
        │ Level2 PPN  │ │ Level2 PPN  │     │           │
        └─────────────┘ └─────────────┘     │           │
                             │              │           │
                             v              v           │
                     ┌─────────────┐ ┌─────────────┐    │
                     │ Level3 PPN  │ │ Level3 PPN  │    │
                     └─────────────┘ └─────────────┘    │
                              │             │           │
                              v             v           v
                      ┌─────────────┐ ┌─────────────┬──────┐
                      │  Data PPN   │ │  Data PPN   │Offset│
                      └─────────────┘ └─────────────┴──────┘
                             │               │
                             v               v
                       Physical Addr   Final Physical Addr</code></pre></div><h3 id="raii-内存管理"><a class="doc-anchor" href="#raii-内存管理">§</a>RAII 内存管理</h3>
<p>页表通过 RAII 机制自动管理所有页表页帧：</p>
<ul>
<li>创建页表时分配根页表页帧</li>
<li>添加映射时按需分配中间页表页帧</li>
<li>销毁页表时自动释放所有页表页帧</li>
</ul>
<h3 id="使用示例"><a class="doc-anchor" href="#使用示例">§</a>使用示例</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 创建新页表
</span><span class="kw">let </span><span class="kw-2">mut </span>page_table = PageTable::new();

<span class="comment">// 建立虚拟页到物理页的映射
</span><span class="kw">let </span>vpn = VirtAddr::from(<span class="number">0x1000_0000</span>).floor();
<span class="kw">let </span>ppn = PhysPageNum(<span class="number">0x80200</span>);
<span class="kw">let </span>flags = PTEFlags::V | PTEFlags::R | PTEFlags::W | PTEFlags::U;
page_table.map(vpn, ppn, flags);

<span class="comment">// 查询地址转换
</span><span class="kw">if let </span><span class="prelude-val">Some</span>(pte) = page_table.translate(vpn) {
    <span class="macro">println!</span>(<span class="string">"虚拟页 {:?} 映射到 {:?}"</span>, vpn, pte.ppn());
}

<span class="comment">// 获取页表令牌供硬件使用
</span><span class="kw">let </span>satp_value = page_table.token();</code></pre></div>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.root_ppn" class="structfield section-header"><a href="#structfield.root_ppn" class="anchor field">§</a><code>root_ppn: <a class="struct" href="../address/struct.PhysPageNum.html" title="struct os::mm::address::PhysPageNum">PhysPageNum</a></code></span><div class="docblock"><p>根页表的物理页号</p>
<p>指向一级页表的物理页面，用于硬件 MMU 开始页表遍历。
该值会被编码到 satp 寄存器中供硬件使用。</p>
</div><span id="structfield.frames" class="structfield section-header"><a href="#structfield.frames" class="anchor field">§</a><code>frames: Vec&lt;<a class="struct" href="../frame_allocator/struct.FrameTracker.html" title="struct os::mm::frame_allocator::FrameTracker">FrameTracker</a>&gt;</code></span><div class="docblock"><p>页表页帧追踪器列表</p>
<p>存储所有页表结构占用的物理页帧，包括根页表和所有中间页表。
通过 RAII 机制确保页表销毁时自动释放所有页帧。</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-PageTable" class="impl"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#436-767">Source</a><a href="#impl-PageTable" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#462-468">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>创建新的页表</p>
<p>分配根页表页帧并初始化页表结构，创建一个空的三级页表。
新创建的页表没有任何映射，所有虚拟地址都未映射。</p>
<h6 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h6>
<p>返回新创建的页表实例</p>
<h6 id="初始化过程"><a class="doc-anchor" href="#初始化过程">§</a>初始化过程</h6>
<ol>
<li>分配一个物理页帧作为根页表</li>
<li>清零页表内容（由 <a href="../frame_allocator/struct.FrameTracker.html#method.new" title="associated function os::mm::frame_allocator::FrameTracker::new"><code>FrameTracker::new()</code></a> 完成）</li>
<li>将页帧添加到 RAII 管理列表</li>
</ol>
<h6 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h6>
<p>如果物理内存不足导致页帧分配失败会触发 panic</p>
<h6 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>page_table = PageTable::new();
<span class="comment">// 此时页表为空，所有地址转换都会失败</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_pte_create" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#500-518">Source</a><h4 class="code-header">fn <a href="#method.find_pte_create" class="fn">find_pte_create</a>(&amp;mut self, vpn: <a class="struct" href="../address/struct.VirtPageNum.html" title="struct os::mm::address::VirtPageNum">VirtPageNum</a>) -&gt; Option&lt;&amp;mut <a class="struct" href="struct.PageTableEntry.html" title="struct os::mm::page_table::PageTableEntry">PageTableEntry</a>&gt;</h4></section></summary><div class="docblock"><p>查找页表项（按需创建中间页表）</p>
<p>在三级页表中查找指定虚拟页号对应的页表项，如果中间页表不存在则自动创建。
主要用于建立新映射时的页表项查找。</p>
<h6 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h6>
<ul>
<li><code>vpn</code> - 要查找的虚拟页号</li>
</ul>
<h6 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h6>
<p>返回指向目标页表项的可变引用，如果创建失败返回 <code>None</code></p>
<h6 id="查找过程"><a class="doc-anchor" href="#查找过程">§</a>查找过程</h6>
<ol>
<li>解析虚拟页号为三级页表索引</li>
<li>从根页表开始逐级查找</li>
<li>如果中间页表项无效，分配新页帧并创建页表</li>
<li>返回三级页表中的目标页表项</li>
</ol>
<h6 id="自动创建机制"><a class="doc-anchor" href="#自动创建机制">§</a>自动创建机制</h6>
<p>当遇到无效的中间页表项时：</p>
<ul>
<li>分配新的物理页帧作为下级页表</li>
<li>设置页表项指向新页表，标志位为 V（仅有效）</li>
<li>将新页帧加入 RAII 管理列表</li>
</ul>
<h6 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h6>
<p>如果页帧分配失败会触发 panic</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_pte" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#546-562">Source</a><h4 class="code-header">fn <a href="#method.find_pte" class="fn">find_pte</a>(&amp;self, vpn: <a class="struct" href="../address/struct.VirtPageNum.html" title="struct os::mm::address::VirtPageNum">VirtPageNum</a>) -&gt; Option&lt;&amp;mut <a class="struct" href="struct.PageTableEntry.html" title="struct os::mm::page_table::PageTableEntry">PageTableEntry</a>&gt;</h4></section></summary><div class="docblock"><p>查找页表项（只读查找）</p>
<p>在三级页表中查找指定虚拟页号对应的页表项，不会创建任何中间页表。
主要用于地址转换和映射状态查询。</p>
<h6 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h6>
<ul>
<li><code>vpn</code> - 要查找的虚拟页号</li>
</ul>
<h6 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h6>
<ul>
<li><code>Some(&amp;mut PageTableEntry)</code> - 找到有效的页表项</li>
<li><code>None</code> - 页表项不存在或中间页表无效</li>
</ul>
<h6 id="查找过程-1"><a class="doc-anchor" href="#查找过程-1">§</a>查找过程</h6>
<ol>
<li>解析虚拟页号为三级页表索引</li>
<li>从根页表开始逐级查找</li>
<li>如果任何中间页表项无效，立即返回 <code>None</code></li>
<li>返回三级页表中的目标页表项</li>
</ol>
<h6 id="与-find_pte_create-的区别"><a class="doc-anchor" href="#与-find_pte_create-的区别">§</a>与 <code>find_pte_create</code> 的区别</h6>
<ul>
<li>本方法只查找，不创建</li>
<li>用于只读操作，不修改页表结构</li>
<li>性能更高，不涉及内存分配</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#600-604">Source</a><h4 class="code-header">pub fn <a href="#method.map" class="fn">map</a>(&amp;mut self, vpn: <a class="struct" href="../address/struct.VirtPageNum.html" title="struct os::mm::address::VirtPageNum">VirtPageNum</a>, ppn: <a class="struct" href="../address/struct.PhysPageNum.html" title="struct os::mm::address::PhysPageNum">PhysPageNum</a>, flags: <a class="struct" href="struct.PTEFlags.html" title="struct os::mm::page_table::PTEFlags">PTEFlags</a>)</h4></section></summary><div class="docblock"><p>建立虚拟页到物理页的映射</p>
<p>在页表中创建从虚拟页号到物理页号的映射关系，并设置相应的访问权限。
如果必要的中间页表不存在，会自动创建。</p>
<h6 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments</h6>
<ul>
<li><code>vpn</code> - 要映射的虚拟页号</li>
<li><code>ppn</code> - 目标物理页号</li>
<li><code>flags</code> - 页面访问权限标志位（自动添加 V 标志）</li>
</ul>
<h6 id="映射过程"><a class="doc-anchor" href="#映射过程">§</a>映射过程</h6>
<ol>
<li>查找或创建到虚拟页的页表项路径</li>
<li>检查目标页表项当前为无效状态</li>
<li>设置页表项指向物理页号，并应用权限标志</li>
<li>自动添加 Valid (V) 标志位使映射生效</li>
</ol>
<h6 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h6>
<p>在以下情况会触发 panic：</p>
<ul>
<li>页帧分配失败导致中间页表创建失败</li>
<li>虚拟页已经被映射（重复映射检查）</li>
</ul>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>page_table = PageTable::new();
<span class="kw">let </span>vpn = VirtAddr::from(<span class="number">0x1000_0000</span>).floor();
<span class="kw">let </span>ppn = PhysPageNum(<span class="number">0x80200</span>);

<span class="comment">// 映射为可读写的用户页
</span><span class="kw">let </span>flags = PTEFlags::R | PTEFlags::W | PTEFlags::U;
page_table.map(vpn, ppn, flags);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unmap" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#642-646">Source</a><h4 class="code-header">pub fn <a href="#method.unmap" class="fn">unmap</a>(&amp;mut self, vpn: <a class="struct" href="../address/struct.VirtPageNum.html" title="struct os::mm::address::VirtPageNum">VirtPageNum</a>)</h4></section></summary><div class="docblock"><p>取消虚拟页的映射</p>
<p>从页表中移除指定虚拟页号的映射关系，使该虚拟地址变为无效。
不会释放物理页帧，只是取消映射关系。</p>
<h6 id="arguments-3"><a class="doc-anchor" href="#arguments-3">§</a>Arguments</h6>
<ul>
<li><code>vpn</code> - 要取消映射的虚拟页号</li>
</ul>
<h6 id="取消映射过程"><a class="doc-anchor" href="#取消映射过程">§</a>取消映射过程</h6>
<ol>
<li>查找虚拟页对应的页表项</li>
<li>检查页表项当前为有效状态</li>
<li>将页表项设置为空（全零）</li>
<li>后续访问该虚拟地址会触发页面错误</li>
</ol>
<h6 id="注意事项"><a class="doc-anchor" href="#注意事项">§</a>注意事项</h6>
<ul>
<li>不会自动释放物理页帧，需要调用者管理</li>
<li>不会回收中间页表，即使它们变为空</li>
<li>取消映射后应刷新 TLB 以确保硬件缓存同步</li>
</ul>
<h6 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h6>
<p>在以下情况会触发 panic：</p>
<ul>
<li>虚拟页未被映射（无效的取消映射操作）</li>
<li>中间页表路径不存在</li>
</ul>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 假设 vpn 已经被映射
</span>page_table.unmap(vpn);
<span class="comment">// 现在访问 vpn 会触发页面错误</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_token" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#680-685">Source</a><h4 class="code-header">pub fn <a href="#method.from_token" class="fn">from_token</a>(satp: usize) -&gt; Self</h4></section></summary><div class="docblock"><p>从 satp 寄存器值创建页表</p>
<p>根据 RISC-V satp (Supervisor Address Translation and Protection) 寄存器的值
创建页表实例，主要用于访问当前硬件正在使用的页表。</p>
<h6 id="arguments-4"><a class="doc-anchor" href="#arguments-4">§</a>Arguments</h6>
<ul>
<li><code>satp</code> - satp 寄存器的值，包含分页模式和根页表地址</li>
</ul>
<h6 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h6>
<p>返回基于现有页表的页表实例</p>
<h6 id="satp-寄存器格式"><a class="doc-anchor" href="#satp-寄存器格式">§</a>satp 寄存器格式</h6><div class="example-wrap"><pre class="language-text"><code>63      60 59           44 43                    0
┌─────────┬──────────────┬─────────────────────────┐
│  MODE   │     ASID     │         PPN             │
│ (4bit)  │   (16bit)    │       (44bit)           │
└─────────┴──────────────┴─────────────────────────┘</code></pre></div><h6 id="注意事项-1"><a class="doc-anchor" href="#注意事项-1">§</a>注意事项</h6>
<ul>
<li>创建的页表实例不管理页帧（<code>frames</code> 为空）</li>
<li>主要用于地址转换，不能用于映射操作</li>
<li>假设页表结构已经由其他方式管理</li>
</ul>
<h6 id="参考资料"><a class="doc-anchor" href="#参考资料">§</a>参考资料</h6>
<p>详细的 satp 寄存器定义请参考 <a href="https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:satp">RISC-V satp 寄存器</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.translate" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#722-724">Source</a><h4 class="code-header">pub fn <a href="#method.translate" class="fn">translate</a>(&amp;self, vpn: <a class="struct" href="../address/struct.VirtPageNum.html" title="struct os::mm::address::VirtPageNum">VirtPageNum</a>) -&gt; Option&lt;<a class="struct" href="struct.PageTableEntry.html" title="struct os::mm::page_table::PageTableEntry">PageTableEntry</a>&gt;</h4></section></summary><div class="docblock"><p>执行虚拟地址转换</p>
<p>查找指定虚拟页号的映射，返回对应的页表项副本。
用于地址转换和权限检查。</p>
<h6 id="arguments-5"><a class="doc-anchor" href="#arguments-5">§</a>Arguments</h6>
<ul>
<li><code>vpn</code> - 要转换的虚拟页号</li>
</ul>
<h6 id="returns-4"><a class="doc-anchor" href="#returns-4">§</a>Returns</h6>
<ul>
<li><code>Some(PageTableEntry)</code> - 找到有效映射，返回页表项副本</li>
<li><code>None</code> - 虚拟页未映射或中间页表无效</li>
</ul>
<h6 id="转换过程"><a class="doc-anchor" href="#转换过程">§</a>转换过程</h6>
<ol>
<li>通过三级页表查找页表项</li>
<li>如果找到有效页表项，返回其副本</li>
<li>如果路径中任何页表无效，返回 <code>None</code></li>
</ol>
<h6 id="使用场景"><a class="doc-anchor" href="#使用场景">§</a>使用场景</h6>
<ul>
<li>虚拟地址到物理地址转换</li>
<li>检查页面映射状态和权限</li>
<li>实现内存管理单元的软件模拟</li>
</ul>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if let </span><span class="prelude-val">Some</span>(pte) = page_table.translate(vpn) {
    <span class="kw">let </span>ppn = pte.ppn();
    <span class="kw">let </span>physical_addr = PhysAddr::from(ppn) + offset;
    <span class="macro">println!</span>(<span class="string">"虚拟地址转换为物理地址: {:?}"</span>, physical_addr);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.token" class="method"><a class="src rightside" href="../../../src/os/mm/page_table.rs.html#764-766">Source</a><h4 class="code-header">pub fn <a href="#method.token" class="fn">token</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>获取页表令牌</p>
<p>生成用于 satp 寄存器的令牌值，包含分页模式和根页表物理页号。
硬件使用此值进行地址转换。</p>
<h6 id="returns-5"><a class="doc-anchor" href="#returns-5">§</a>Returns</h6>
<p>返回格式化的 satp 寄存器值</p>
<h6 id="令牌格式"><a class="doc-anchor" href="#令牌格式">§</a>令牌格式</h6><div class="example-wrap"><pre class="language-text"><code>63      60 59           44 43                    0
┌─────────┬──────────────┬─────────────────────────┐
│    8    │      0       │      root_ppn.0         │
│ (SV39)  │   (ASID)     │   (Root Page PPN)       │
└─────────┴──────────────┴─────────────────────────┘</code></pre></div><h6 id="模式说明"><a class="doc-anchor" href="#模式说明">§</a>模式说明</h6>
<ul>
<li>MODE = 8: 表示 SV39 分页模式</li>
<li>ASID = 0: 地址空间标识符，暂时使用 0</li>
<li>PPN: 根页表的物理页号</li>
</ul>
<p>参考：<a href="https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:satp">satp寄存器</a></p>
<h6 id="使用方式"><a class="doc-anchor" href="#使用方式">§</a>使用方式</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>token = page_table.token();
<span class="comment">// 将 token 写入 satp 寄存器激活页表
</span><span class="kw">unsafe </span>{
    <span class="macro">asm!</span>(<span class="string">"csrw satp, {}"</span>, <span class="kw">in</span>(reg) token);
    <span class="comment">// 刷新 TLB
    </span><span class="macro">asm!</span>(<span class="string">"sfence.vma"</span>);
}</code></pre></div>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-PageTable" class="impl"><a href="#impl-Freeze-for-PageTable" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></h3></section><section id="impl-RefUnwindSafe-for-PageTable" class="impl"><a href="#impl-RefUnwindSafe-for-PageTable" class="anchor">§</a><h3 class="code-header">impl RefUnwindSafe for <a class="struct" href="struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></h3></section><section id="impl-Send-for-PageTable" class="impl"><a href="#impl-Send-for-PageTable" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></h3></section><section id="impl-Sync-for-PageTable" class="impl"><a href="#impl-Sync-for-PageTable" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></h3></section><section id="impl-Unpin-for-PageTable" class="impl"><a href="#impl-Unpin-for-PageTable" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></h3></section><section id="impl-UnwindSafe-for-PageTable" class="impl"><a href="#impl-UnwindSafe-for-PageTable" class="anchor">§</a><h3 class="code-header">impl UnwindSafe for <a class="struct" href="struct.PageTable.html" title="struct os::mm::page_table::PageTable">PageTable</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>