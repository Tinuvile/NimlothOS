应用程序与操作系统需要通过某种合作机制完成特权级的切换，使得用户态应用程序可以得到内核态操作系统函数的服务。这就是这部分的任务。

我们的批处理操作系统被设计为运行在内核态特权级，而应用程序在用户态特权级，它的执行环境就是BatchOS批处理操作系统提供的AEE（Application Execution Environment）。

批处理操作系统的任务大致是：
- 启动应用程序时，初始化应用程序的用户态上下文，并能切换到用户态执行应用程序；
- 应用程序发起系统调用（Trap）后，需进行处理；
- 应用程序执行出错时，杀死并加载下一个应用；
- 应用程序执行结束时，加载运行下一个应用

S特权级中与Trap相关的控制状态寄存器CSR（Control and Status Register）如下：

| CSR 名  | 该 CSR 与 Trap 相关的功能                          |
| ------- | -------------------------------------------------- |
| sstatus | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
| sepc    | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
| scause  | 描述 Trap 的原因                                   |
| stval   | 给出 Trap 附加信息                                 |
| stvec   | 控制 Trap 处理代码的入口地址                       |

特权级切换的过程由硬件和操作系统协作完成。

当CPU执行完一条指令并准备从`U`通过`trap`到`S`时，硬件会：
- 修改`sstatus`的`SPP`字段为CPU当前特权级
- 修改`sepc`为被中断或触发异常的指令地址
- 修改`scause/stval`为`trap`原因以及相关附加信息
- CPU跳转到`stvec`设置的`trap`处理入口，并将当前特权级设置为`S`，然后开始执行

> `stvec`有两个字段：`MODE`位于`[1:0]`
、`BASE`位于`[63:2]`，当`MODE`字段为0时，`stvec`被设置为`Direct`模式，此时进入S模式的Trap无论原因，处理Trap的入口地址都是`BASE<<2`，CPU会跳转到这个地方进行异常处理。`stvec`还可被设置为`Vectored`模式。

而当CPU完成`trap`返回时，通过`sret`指令完成，这是一条`S`特权级指令，它会完成：
- 设置当前特权级为`sstatus`字段内容
- 跳转到`sepc`寄存器指向的指令，继续执行

在`trap`跳转进入`S`进行处理前，需要保存原控制流的寄存器状态，通常通过内核栈来保存。

因此我们会在操作系统中通过一段汇编代码，从用户栈切换到内核栈，并在栈上保存控制流的寄存器状态。

`batch.rs`中声明两个类型分别表示两个栈，都是8KiB大小。RISC-V中栈是向下增长的，换栈时也只需要将`sp`寄存器改为`get_sp`的返回值。

`trap`发生时需要保存的上下文定义在`TrapContext`中，主要是通用寄存器、`sstatus`和`sepc`。

```rust
pub struct TrapContext {
    /// general regs[0..31]
    pub x: [usize; 32],
    /// CSR sstatus
    pub sstatus: Sstatus,
    /// CSR sepc
    pub sepc: usize,
}
```

`trap`部分的过程主要是：
- 应用程序通过`ecall`进入内核状态，操作系统保存被打断的应用程序的`trap`上下文
- 操作系统根据`trap`相关CSR寄存器内容，完成系统调用服务的分发与处理
- 操作系统完成系统调用服务后，恢复被打断的应用程序的`trap`上下文，并通过`sret`让应用程序继续执行

首先操作系统初始化时需要修改`stvec`寄存器指向正确的`trap`处理入口点:

```rust
pub fn init() {
    unsafe extern "C" {
        fn __alltraps();
    }
    unsafe {
        stvec::write(__alltraps as usize, TrapMode::Direct);
    }
}
```

这里使用`Direct`模式，所有`trap`处理都走一个入口点。

`__alltraps`和`__restore`的实现在`trap.S`中，分别负责把`trap`上下文保存到内核栈和从内核栈恢复上下文。

`trap`的分发处理在`trap_handler`函数中：

```rust
pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
    let scause = scause::read();
    let stval = stval::read();
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            cx.sepc += 4;
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
        Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) => {
            println!("[kernel] PageFault in application, kernel killed it.");
            run_next_app();
        }
        Trap::Exception(Exception::IllegalInstruction) => {
            println!("[kernel] IllegalInstruction in application, kernel killed it.");
            run_next_app();
        }
        _ => {
            panic!(
                "Unsupported trap {:?}, stval = {:#x}!",
                scause.cause(),
                stval,
            );
        }
    }
    cx
}
```

使用Rust的riscv库来根据`trap`的原因进行分发处理。

系统调用的实现在`syscall`中，它会根据`syscall ID`进行分发，然后具体处理函数处理。

```text
ABI命名约定

zero (x0): 零寄存器
ra (x1):   Return Address
sp (x2):   Stack Pointer  
gp (x3):   Global Pointer
tp (x4):   Thread Pointer
t0-t2 (x5-x7):  Temporary registers
s0/fp (x8):  Saved register / Frame pointer
s1 (x9):   Saved register
a0-a7 (x10-x17): Argument registers
s2-s11 (x18-x27): Saved registers
t3-t6 (x28-x31): Temporary registers
```

运行结果：

```bash
Hello, world!
[kernel] num_app = 5
[kernel] app_0 [0x8020b038, 0x8020c040)
[kernel] app_1 [0x8020c040, 0x8020d0e8)
[kernel] app_2 [0x8020d0e8, 0x8020e4a8)
[kernel] app_3 [0x8020e4a8, 0x8020f538)
[kernel] app_4 [0x8020f538, 0x802105c8)
[kernel] Loading app_0 ...
Hello, world!
[kernel] Application exited with code 0[kernel] Loading app_1 ...
Info Test StoreFault, we will insert an invalid store operation...
Kernel should kill this application
[kernel] PageFault in application, kernel killed it.
[kernel] Loading app_2 ...
2^10000=3909(MOD 10007)
2^20000=9599(MOD 10007)
2^30000=6248(MOD 10007)
2^40000=6352(MOD 10007)
2^50000=2601(MOD 10007)
2^60000=197(MOD 10007)
2^70000=9541(MOD 10007)
2^80000=9687(MOD 10007)
2^90000=10002(MOD 10007)
2^100000=469(MOD 10007)
Power Test Passed!
[kernel] Application exited with code 0[kernel] Loading app_3 ...
Try to execute privileged instruction in U Mode
Kernel should kill this application!
[kernel] IllegalInstruction in application, kernel killed it.
[kernel] Loading app_4 ...
Try to access privileged CSR in U Mode
Kernel should kill this application!
[kernel] IllegalInstruction in application, kernel killed it.
All applications completed!
```