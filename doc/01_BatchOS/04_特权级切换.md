应用程序与操作系统需要通过某种合作机制完成特权级的切换，使得用户态应用程序可以得到内核态操作系统函数的服务。这就是这部分的任务。

我们的批处理操作系统被设计为运行在内核态特权级，而应用程序在用户态特权级，它的执行环境就是BatchOS批处理操作系统提供的AEE（Application Execution Environment）。

批处理操作系统的任务大致是：
- 启动应用程序时，初始化应用程序的用户态上下文，并能切换到用户态执行应用程序；
- 应用程序发起系统调用（Trap）后，需进行处理；
- 应用程序执行出错时，杀死并加载下一个应用；
- 应用程序执行结束时，加载运行下一个应用

S特权级中与Trap相关的控制状态寄存器CSR（Control and Status Register）如下：

| CSR 名  | 该 CSR 与 Trap 相关的功能                          |
| ------- | -------------------------------------------------- |
| sstatus | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
| sepc    | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
| scause  | 描述 Trap 的原因                                   |
| stval   | 给出 Trap 附加信息                                 |
| stvec   | 控制 Trap 处理代码的入口地址                       |

> `stvec`有两个字段：`MODE`位于`[1:0]`
、`BASE`位于`[63:2]`，当`MODE`字段为0时，`stvec`被设置为`Direct`模式，此时进入S模式的Trap无论原因，处理Trap的入口地址都是`BASE<<2`，CPU会跳转到这个地方进行异常处理。`stvec`还可被设置为`Vectored`模式。

特权级切换的核心是Trap管理：
- 程序通过`ecall`进入内核，操作系统保存被打断的应用程序的`trap`上下文
- 操作系统根据`trap`相关CSR寄存器内容，完成系统调用服务的分发与处理
- 完成后，需恢复被打断的应用程序的`trap`上下文，并通过`sret`让应用程序继续执行

```text
ABI命名约定

zero (x0): 零寄存器
ra (x1):   Return Address
sp (x2):   Stack Pointer  
gp (x3):   Global Pointer
tp (x4):   Thread Pointer
t0-t2 (x5-x7):  Temporary registers
s0/fp (x8):  Saved register / Frame pointer
s1 (x9):   Saved register
a0-a7 (x10-x17): Argument registers
s2-s11 (x18-x27): Saved registers
t3-t6 (x28-x31): Temporary registers
```