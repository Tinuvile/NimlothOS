## 打印调用栈

根据RISC-V的调用约定，RISC-V的栈帧结构是：

```text
高地址
+------------------+
| 局部变量          |  <- sp (栈指针)
+------------------+
| 保存的寄存器       |
+------------------+
| 返回地址 (RA)     |  <- fp-1
+------------------+
| 上一个帧指针       |  <- fp-2 (当前fp指向这里)
+------------------+
低地址

假设函数分配了 32 字节的栈空间：

0x8040FF20: [局部变量]           <- sp (栈顶)
0x8040FF18: [保存的寄存器 s1]
0x8040FF10: [保存的寄存器 s2]
0x8040FF08: [返回地址 RA]        <- s0-8
0x8040FF00: [上一个帧指针]       <- s0-16
0x8040FEF8: [保存的寄存器 s0]    <- s0-24
0x8040FEF0: [其他数据]           <- s0-32

s0 指向 0x8040FF08 (栈帧基址)
sp 指向 0x8040FF20 (栈顶)
```

通过汇编语法获取`s0`的值并打印函数调用栈：

```rust
pub unsafe fn print_stack_trace() {
    let mut fp: *const usize;
    asm!("mv {}, s0", out(reg) fp);

    println!("=== Call Stack Trace Tool ===");
    while fp != ptr::null() {
        let saved_ra = *fp.sub(1);
        let saved_fp = *fp.sub(2);

        println!("0x{:016x} (0x{:016x})", saved_ra, saved_fp);

        fp = saved_fp as *const usize;
    }
    println!("=== End of Call Stack Trace ===");
}
```

## 扩展内核-系统调用`get_taskinfo`

