这里要实现的是：
- 分时多任务：操作系统管理每个应用程序，以时间片为单位来分时占用处理器运行应用。
- 时间片轮转调度：操作系统在一个程序用完其时间片后，就抢占当前程序并调用下一个程序执行

我们使用时间片轮转（RR, Round-Robin）算法进行应用调度。维护一个任务队列，每次从队头取出一个应用执行一个时间片，然后把它置于队尾，再继续从队头取出一个应用，直到所有应用执行完毕。

不考虑指令集拓展，RISC-V架构中定义了如下中断：

| Interrupt | Exception Code | Description                  |
|-----------|----------------|------------------------------|
| 1         | 1              | Supervisor software interrupt |
| 1         | 3              | Machine software interrupt    |
| 1         | 5              | Supervisor timer interrupt    |
| 1         | 7              | Machine timer interrupt       |
| 1         | 9              | Supervisor external interrupt |
| 1         | 11             | Machine external interrupt    |

它们可以分为三类：
- 软件中断：由软件控制发出的中断
- 时钟中断：由时钟电路发出的中断
- 外部中断：由外设发出的中断

中断的特权级可以决定它是否会被屏蔽，以及需要`trap`到哪个特权级进行处理。如果特权级低于CPU当前的，则它会被屏蔽；而如果相同或更高，则需通过相应的CSR判断该中断是否会被屏蔽。

以内核所在的 S 特权级为例，中断屏蔽相应的 CSR 有`sstatus`和`sie`。`sstatus`的`sie`为 S 特权级的中断使能，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽。即使`sstatus.sie`置 1 ，还要看`sie`这个 CSR，它的三个字段`ssie/stie/seie`分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能。比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要`sstatus.sie`和`sie.stie`均为 1 该中断才不会被屏蔽；如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽。

如果中断没有被屏蔽，则需要软件进行处理。默认情况下所有中断都需到 M 特权级处理，并且当中断产生并进入某个特权级之后，在中断处理的过程中同特权级的中断都会被屏蔽。中断产生后，硬件会完成如下事务：
- 当中断发生时，`sstatus.sie`字段会被保存在`sstatus.spie`字段中，同时把`sstatus.sie`字段置零，这样软件在进行后续的中断处理过程中，所有 S 特权级的中断都会被屏蔽；
- 当软件执行中断处理完毕后，会执行`sret`指令返回到被中断打断的地方继续执行，硬件会把`sstatus.sie`字段恢复为`sstatus.spie`字段内的值。

RISC-V 处理器有一个内置的时钟，还有一个计数器用来统计处理器自上电以来经过了多少个内置时钟的时钟周期，它保存在一个64位的CSR`mtime`中，可以在所有特权级通过`rdtime`访问，我们使用`riscv`库封装号的接口即可。

还有一个64位的CSR`mtimecmp`，当`mtime`的值超过了`mtimecmp`，就会触发一次时钟中断。我们通过`set_timer`来设置这个寄存器的值，它调用运行在 M 特权级的 SEE（此处是`rustsbi`）中的相关接口。

抢断式调度的实现就是，当发现触发了一个 S 特权级时钟中断，首先重新设置一个 10 ms计时器，然后调用`suspend_current_and_run_next`函数暂停当前应用并切换到下一个。

