## 用户态和内核态运行时间统计

很精妙，围绕切换函数`trap_handler`展开

## 支持浮点应用程序

`trap.S`中需要添加浮点寄存器的存储与恢复。

此外，支持浮点指令可能还需要(包括但不限于)以下条件：

- 机器本身支持浮点指令
- Rust 编译目标包含浮点指令：在`os/Makefile`中的`TARGET := riscv64gc-unknown-none-elf`支持浮点指令，而对应的`riscv64imac`则不支持。
- 需要通过控制浮点控制状态寄存器（如`fcsr`）来检查FPU状态。具体可见[3.1.6.6](https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-status-registers-mstatus-and-mstatush)

再就是要开启F/D扩展，由于在`config.toml`里面设置目标特性没成功，显示是`unsable`，在`cargo.toml`里面启用`unsable`依然不行，所以选择在汇编文件处显式声明架构。

## 统计任务切换的大致开销

围绕`__switch`函数，一开始直接把它包装一下，头尾加一个计时装置，但是运行结果是`task switch time: 178536 us`，时间太长了，显然不对。

这里要考虑：
- 进入`switch::__switch`函数时，`ra`会被设置成当前指令的下一个指令
- 当执行`switch::__switch`的`ret`指令时，`pc`会被设置成另一个`task`的`ra`。
  - 如果该`task`是初次运行，那么`ra`是`__restore`，那么会直接回到用户态从头开始执行`task`。这种情况下，后面的代码被跳过了，导致`switch`时间没有被记录
  - 如果不是，那么`ra`就是下一条指令。这个时间被正常记录了。