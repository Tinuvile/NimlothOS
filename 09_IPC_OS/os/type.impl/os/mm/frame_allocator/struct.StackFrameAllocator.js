(function() {
    var type_impls = Object.fromEntries([["os",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FrameAllocator-for-StackFrameAllocator\" class=\"impl\"><a class=\"src rightside\" href=\"src/os/mm/frame_allocator.rs.html#215-294\">Source</a><a href=\"#impl-FrameAllocator-for-StackFrameAllocator\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"os/mm/frame_allocator/trait.FrameAllocator.html\" title=\"trait os::mm::frame_allocator::FrameAllocator\">FrameAllocator</a> for <a class=\"struct\" href=\"os/mm/frame_allocator/struct.StackFrameAllocator.html\" title=\"struct os::mm::frame_allocator::StackFrameAllocator\">StackFrameAllocator</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/os/mm/frame_allocator.rs.html#224-230\">Source</a><a href=\"#method.new\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"os/mm/frame_allocator/trait.FrameAllocator.html#tymethod.new\" class=\"fn\">new</a>() -&gt; Self</h4></section></summary><div class=\"docblock\"><p>创建新的栈式分配器实例</p>\n<p>创建一个空的分配器实例，所有字段都初始化为 0 或空状态。\n需要调用 [<code>init()</code>] 方法才能开始分配页帧。</p>\n<h6 id=\"returns\"><a class=\"doc-anchor\" href=\"#returns\">§</a>Returns</h6>\n<p>返回未初始化的分配器实例</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.alloc\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/os/mm/frame_allocator.rs.html#251-262\">Source</a><a href=\"#method.alloc\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"os/mm/frame_allocator/trait.FrameAllocator.html#tymethod.alloc\" class=\"fn\">alloc</a>(&amp;mut self) -&gt; Option&lt;<a class=\"struct\" href=\"os/mm/address/struct.PhysPageNum.html\" title=\"struct os::mm::address::PhysPageNum\">PhysPageNum</a>&gt;</h4></section></summary><div class=\"docblock\"><p>分配一个物理页帧</p>\n<p>实现栈式分配策略：优先从回收列表弹出页帧，如果回收列表为空\n则从连续区间分配新页帧。</p>\n<h6 id=\"returns-1\"><a class=\"doc-anchor\" href=\"#returns-1\">§</a>Returns</h6>\n<ul>\n<li><code>Some(ppn)</code> - 成功分配的物理页号</li>\n<li><code>None</code> - 内存耗尽，无可用页帧</li>\n</ul>\n<h6 id=\"分配逻辑\"><a class=\"doc-anchor\" href=\"#分配逻辑\">§</a>分配逻辑</h6>\n<ol>\n<li><strong>回收列表优先</strong>：如果 <code>recycled</code> 非空，弹出最后一个页号</li>\n<li><strong>连续分配</strong>：如果回收列表为空且 <code>current &lt; end</code>，分配 <code>current</code> 页号并递增</li>\n<li><strong>分配失败</strong>：如果连续区间耗尽且回收列表为空，返回 <code>None</code></li>\n</ol>\n<h6 id=\"时间复杂度\"><a class=\"doc-anchor\" href=\"#时间复杂度\">§</a>时间复杂度</h6>\n<p>O(1) - 所有操作都是常数时间</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.dealloc\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/os/mm/frame_allocator.rs.html#287-293\">Source</a><a href=\"#method.dealloc\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"os/mm/frame_allocator/trait.FrameAllocator.html#tymethod.dealloc\" class=\"fn\">dealloc</a>(&amp;mut self, ppn: <a class=\"struct\" href=\"os/mm/address/struct.PhysPageNum.html\" title=\"struct os::mm::address::PhysPageNum\">PhysPageNum</a>)</h4></section></summary><div class=\"docblock\"><p>释放一个物理页帧</p>\n<p>将页帧回收到回收列表中，使其可以被再次分配。进行安全性检查\n防止释放无效或重复释放的页帧。</p>\n<h6 id=\"arguments\"><a class=\"doc-anchor\" href=\"#arguments\">§</a>Arguments</h6>\n<ul>\n<li><code>ppn</code> - 要释放的物理页号</li>\n</ul>\n<h6 id=\"安全性检查\"><a class=\"doc-anchor\" href=\"#安全性检查\">§</a>安全性检查</h6>\n<ul>\n<li><strong>有效性检查</strong>：页号必须小于 <code>current</code>（已分配过）</li>\n<li><strong>重复释放检查</strong>：页号不能已存在于回收列表中</li>\n</ul>\n<h6 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h6>\n<p>在以下情况下会触发 panic：</p>\n<ul>\n<li><code>ppn &gt;= current</code>：释放未分配的页帧</li>\n<li><code>ppn</code> 已存在于回收列表：重复释放同一页帧</li>\n</ul>\n<h6 id=\"时间复杂度-1\"><a class=\"doc-anchor\" href=\"#时间复杂度-1\">§</a>时间复杂度</h6>\n<p>O(R) - R 为回收列表长度，用于重复释放检查</p>\n</div></details></div></details>","FrameAllocator","os::mm::frame_allocator::FrameAllocatorImpl"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-StackFrameAllocator\" class=\"impl\"><a class=\"src rightside\" href=\"src/os/mm/frame_allocator.rs.html#176-213\">Source</a><a href=\"#impl-StackFrameAllocator\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"os/mm/frame_allocator/struct.StackFrameAllocator.html\" title=\"struct os::mm::frame_allocator::StackFrameAllocator\">StackFrameAllocator</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.init\" class=\"method\"><a class=\"src rightside\" href=\"src/os/mm/frame_allocator.rs.html#209-212\">Source</a><h4 class=\"code-header\">pub fn <a href=\"os/mm/frame_allocator/struct.StackFrameAllocator.html#tymethod.init\" class=\"fn\">init</a>(&amp;mut self, l: <a class=\"struct\" href=\"os/mm/address/struct.PhysPageNum.html\" title=\"struct os::mm::address::PhysPageNum\">PhysPageNum</a>, r: <a class=\"struct\" href=\"os/mm/address/struct.PhysPageNum.html\" title=\"struct os::mm::address::PhysPageNum\">PhysPageNum</a>)</h4></section></summary><div class=\"docblock\"><p>初始化页帧分配器</p>\n<p>设置分配器的可分配页帧范围，该范围通常是从内核镜像结束\n到物理内存结束的连续物理页面。</p>\n<h6 id=\"arguments\"><a class=\"doc-anchor\" href=\"#arguments\">§</a>Arguments</h6>\n<ul>\n<li><code>l</code> - 起始物理页号（包含）</li>\n<li><code>r</code> - 结束物理页号（不包含）</li>\n</ul>\n<h6 id=\"分配范围\"><a class=\"doc-anchor\" href=\"#分配范围\">§</a>分配范围</h6>\n<p>分配器将管理区间 <code>[l, r)</code> 内的所有物理页帧：</p>\n<ul>\n<li>总共 <code>r - l</code> 个可分配页帧</li>\n<li>每个页帧大小为 4KB (PAGE_SIZE)</li>\n<li>页帧按页号递增顺序分配</li>\n</ul>\n<h6 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h6>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>start_ppn = PhysAddr::from(<span class=\"number\">0x80400000</span>).ceil(); <span class=\"comment\">// 内核后第一页\n</span><span class=\"kw\">let </span>end_ppn = PhysAddr::from(<span class=\"number\">0x88000000</span>).floor();  <span class=\"comment\">// 物理内存最后一页\n</span>allocator.init(start_ppn, end_ppn);\n<span class=\"comment\">// 现在可以分配 [start_ppn, end_ppn) 范围内的页帧</span></code></pre></div>\n<h6 id=\"postconditions\"><a class=\"doc-anchor\" href=\"#postconditions\">§</a>Postconditions</h6>\n<p>初始化后分配器状态：</p>\n<ul>\n<li><code>current = l.0</code>：从起始页号开始分配</li>\n<li><code>end = r.0</code>：设置分配上界</li>\n<li><code>recycled</code> 保持空列表</li>\n</ul>\n</div></details></div></details>",0,"os::mm::frame_allocator::FrameAllocatorImpl"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[7828]}